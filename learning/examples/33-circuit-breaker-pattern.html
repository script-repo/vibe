<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circuit Breaker Pattern</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }
        .container { max-width: 1000px; margin: 0 auto; }
        h1 { color: #333; margin-bottom: 30px; }
        .panel {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        .state {
            display: inline-block;
            padding: 10px 20px;
            border-radius: 6px;
            font-weight: bold;
            margin: 10px 0;
        }
        .state.CLOSED { background: #d1fae5; color: #065f46; }
        .state.OPEN { background: #fee2e2; color: #991b1b; }
        .state.HALF_OPEN { background: #fef3c7; color: #92400e; }
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            background: #667eea;
            color: white;
            font-weight: bold;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #5568d3; }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .metric {
            background: #f9fafb;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 32px;
            font-weight: bold;
            color: #667eea;
        }
        .metric-label {
            color: #666;
            font-size: 14px;
            margin-top: 5px;
        }
        .log {
            background: #1e293b;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
        .log-entry {
            margin-bottom: 5px;
        }
        .log-entry.success { color: #4ade80; }
        .log-entry.error { color: #ef4444; }
        .log-entry.info { color: #3b82f6; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Circuit Breaker Pattern for Fault Tolerance</h1>

        <div class="panel">
            <h2>Circuit State</h2>
            <div>Current State: <span class="state CLOSED" id="stateDisplay">CLOSED</span></div>

            <div class="metrics">
                <div class="metric">
                    <div class="metric-value" id="successCount">0</div>
                    <div class="metric-label">Successful Requests</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="failureCount">0</div>
                    <div class="metric-label">Failed Requests</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="rejectedCount">0</div>
                    <div class="metric-label">Rejected Requests</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="failureRate">0%</div>
                    <div class="metric-label">Failure Rate</div>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2>Test Circuit Breaker</h2>
            <button onclick="breaker.testSuccessfulRequest()">Successful Request</button>
            <button onclick="breaker.testFailedRequest()">Failed Request</button>
            <button onclick="breaker.simulateFailureScenario()">Simulate Failure Scenario</button>
            <button onclick="breaker.reset()">Reset Circuit</button>
        </div>

        <div class="panel">
            <h2>Request Log</h2>
            <div class="log" id="log"></div>
        </div>
    </div>

    <script>
        // Circuit Breaker States
        const States = {
            CLOSED: 'CLOSED',       // Normal operation
            OPEN: 'OPEN',           // Failing, rejecting requests
            HALF_OPEN: 'HALF_OPEN'  // Testing recovery
        };

        class CircuitBreaker {
            constructor(options = {}) {
                this.failureThreshold = options.failureThreshold || 5;
                this.recoveryTimeout = options.recoveryTimeout || 60000; // 60 seconds
                this.monitoringPeriod = options.monitoringPeriod || 10000; // 10 seconds
                this.successThreshold = options.successThreshold || 2; // For HALF_OPEN

                this.state = States.CLOSED;
                this.failureCount = 0;
                this.successCount = 0;
                this.rejectedCount = 0;
                this.lastFailureTime = null;
                this.nextAttemptTime = null;

                // Request history for failure rate calculation
                this.requestHistory = [];

                this.updateDisplay();
            }

            async execute(request) {
                // Check circuit state
                if (this.state === States.OPEN) {
                    if (Date.now() < this.nextAttemptTime) {
                        // Still in timeout period
                        this.rejectedCount++;
                        this.log('error', 'Request rejected - Circuit OPEN');
                        this.updateDisplay();
                        throw new Error('Circuit breaker is OPEN');
                    } else {
                        // Timeout expired, transition to HALF_OPEN
                        this.transitionTo(States.HALF_OPEN);
                    }
                }

                try {
                    // Execute the request
                    const result = await request();

                    // Record success
                    this.onSuccess();

                    return result;
                } catch (error) {
                    // Record failure
                    this.onFailure();
                    throw error;
                }
            }

            onSuccess() {
                this.recordRequest(true);
                this.successCount++;

                if (this.state === States.HALF_OPEN) {
                    // Check if we've had enough successes to close circuit
                    if (this.getRecentSuccesses() >= this.successThreshold) {
                        this.log('success', `${this.successThreshold} consecutive successes - Closing circuit`);
                        this.transitionTo(States.CLOSED);
                        this.failureCount = 0;
                    }
                } else if (this.state === States.CLOSED) {
                    // Reset failure count on success in CLOSED state
                    this.failureCount = 0;
                }

                this.log('success', 'Request succeeded');
                this.updateDisplay();
            }

            onFailure() {
                this.recordRequest(false);
                this.failureCount++;
                this.lastFailureTime = Date.now();

                this.log('error', `Request failed (${this.failureCount} failures)`);

                if (this.state === States.HALF_OPEN) {
                    // Any failure in HALF_OPEN state reopens the circuit
                    this.log('error', 'Failure during HALF_OPEN - Reopening circuit');
                    this.transitionTo(States.OPEN);
                } else if (this.state === States.CLOSED) {
                    // Check if we've exceeded failure threshold
                    const failureRate = this.calculateFailureRate();

                    if (this.failureCount >= this.failureThreshold) {
                        this.log('error', `Failure threshold (${this.failureThreshold}) exceeded - Opening circuit`);
                        this.transitionTo(States.OPEN);
                    }
                }

                this.updateDisplay();
            }

            transitionTo(newState) {
                const oldState = this.state;
                this.state = newState;

                if (newState === States.OPEN) {
                    this.nextAttemptTime = Date.now() + this.recoveryTimeout;
                    this.log('info', `Circuit OPEN - Will retry in ${this.recoveryTimeout/1000}s`);
                } else if (newState === States.HALF_OPEN) {
                    this.log('info', 'Circuit HALF_OPEN - Testing recovery');
                } else if (newState === States.CLOSED) {
                    this.log('success', 'Circuit CLOSED - Normal operation');
                }

                this.updateDisplay();
            }

            recordRequest(success) {
                const now = Date.now();
                this.requestHistory.push({ time: now, success });

                // Remove old entries outside monitoring period
                this.requestHistory = this.requestHistory.filter(
                    req => now - req.time < this.monitoringPeriod
                );
            }

            calculateFailureRate() {
                if (this.requestHistory.length === 0) return 0;

                const failures = this.requestHistory.filter(req => !req.success).length;
                return failures / this.requestHistory.length;
            }

            getRecentSuccesses() {
                const recent = this.requestHistory.slice(-this.successThreshold);
                return recent.filter(req => req.success).length;
            }

            // Test methods
            async testSuccessfulRequest() {
                try {
                    await this.execute(async () => {
                        // Simulate successful API call
                        await new Promise(resolve => setTimeout(resolve, 200));
                        return { success: true };
                    });
                } catch (error) {
                    // Request rejected by circuit breaker
                }
            }

            async testFailedRequest() {
                try {
                    await this.execute(async () => {
                        // Simulate failed API call
                        await new Promise(resolve => setTimeout(resolve, 200));
                        throw new Error('Service unavailable');
                    });
                } catch (error) {
                    // Expected failure
                }
            }

            async simulateFailureScenario() {
                this.log('info', 'Simulating cascading failure scenario...');

                // Send 6 failed requests to trip the circuit
                for (let i = 0; i < 6; i++) {
                    await this.testFailedRequest();
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                // Try a request while circuit is open (should be rejected)
                await this.testSuccessfulRequest();
            }

            reset() {
                this.state = States.CLOSED;
                this.failureCount = 0;
                this.successCount = 0;
                this.rejectedCount = 0;
                this.requestHistory = [];
                this.lastFailureTime = null;
                this.nextAttemptTime = null;

                this.log('info', 'Circuit breaker reset');
                this.updateDisplay();
            }

            updateDisplay() {
                // Update state display
                const stateDisplay = document.getElementById('stateDisplay');
                stateDisplay.textContent = this.state;
                stateDisplay.className = `state ${this.state}`;

                // Update metrics
                document.getElementById('successCount').textContent = this.successCount;
                document.getElementById('failureCount').textContent = this.failureCount;
                document.getElementById('rejectedCount').textContent = this.rejectedCount;

                const failureRate = this.calculateFailureRate();
                document.getElementById('failureRate').textContent =
                    `${(failureRate * 100).toFixed(1)}%`;
            }

            log(type, message) {
                const logDiv = document.getElementById('log');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;

                const timestamp = new Date().toLocaleTimeString();
                entry.textContent = `[${timestamp}] ${message}`;

                logDiv.insertBefore(entry, logDiv.firstChild);
            }
        }

        // Initialize circuit breaker
        const breaker = new CircuitBreaker({
            failureThreshold: 5,
            recoveryTimeout: 10000,  // 10 seconds for demo
            monitoringPeriod: 10000,
            successThreshold: 2
        });
    </script>
</body>
</html>
