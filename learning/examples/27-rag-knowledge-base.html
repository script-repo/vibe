<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RAG-Powered Knowledge Base</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            font-size: 32px;
        }
        .panel {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 20px;
        }
        .api-key-section {
            margin-bottom: 15px;
        }
        input[type="text"], input[type="password"], textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            margin-bottom: 10px;
            transition: border-color 0.3s;
        }
        input:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: #667eea;
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        button:hover {
            background: #5568d3;
            transform: translateY(-1px);
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        .document-list {
            margin-top: 15px;
        }
        .document-item {
            background: #f5f5f5;
            padding: 10px 15px;
            margin-bottom: 8px;
            border-radius: 6px;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .search-section {
            margin-top: 20px;
        }
        .search-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .search-controls input {
            flex: 1;
            margin: 0;
        }
        .slider-control {
            margin-bottom: 15px;
        }
        .slider-control label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
            color: #666;
        }
        input[type="range"] {
            width: 100%;
        }
        .result {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid #667eea;
        }
        .result-score {
            color: #667eea;
            font-weight: bold;
            font-size: 12px;
        }
        .result-source {
            color: #999;
            font-size: 12px;
            margin-top: 5px;
        }
        .result-content {
            margin: 10px 0;
            color: #333;
            line-height: 1.6;
        }
        .status {
            background: #e3f2fd;
            color: #1976d2;
            padding: 10px 15px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 13px;
        }
        .error {
            background: #ffebee;
            color: #c62828;
        }
        .success {
            background: #e8f5e9;
            color: #2e7d32;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .stat-item {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>RAG-Powered Knowledge Base</h1>

        <div class="panel">
            <h2>OpenAI Configuration</h2>
            <div class="api-key-section">
                <input type="password" id="apiKey" placeholder="Enter your OpenAI API key">
                <button onclick="app.saveApiKey()">Save API Key</button>
            </div>
        </div>

        <div class="panel">
            <h2>Add Documents</h2>
            <textarea id="documentText" rows="4" placeholder="Paste your document text here..."></textarea>
            <input type="text" id="documentSource" placeholder="Document source/title (optional)">
            <button onclick="app.addDocument()" id="addDocBtn">Add to Knowledge Base</button>
            <div id="addStatus"></div>

            <div class="document-list">
                <h3 style="font-size: 16px; margin: 15px 0 10px 0; color: #666;">Documents (<span id="docCount">0</span>)</h3>
                <div id="documentsList"></div>
            </div>
        </div>

        <div class="panel">
            <h2>Search Knowledge Base</h2>
            <div class="search-controls">
                <input type="text" id="queryInput" placeholder="Ask a question...">
                <button onclick="app.search()" id="searchBtn">Search</button>
            </div>

            <div class="slider-control">
                <label>
                    <span>Hybrid Search Alpha (Vector ← → Keyword)</span>
                    <span id="alphaValue">0.7</span>
                </label>
                <input type="range" id="alphaSlider" min="0" max="1" step="0.1" value="0.7">
            </div>

            <div class="slider-control">
                <label>
                    <span>Max Results</span>
                    <span id="maxResultsValue">3</span>
                </label>
                <input type="range" id="maxResultsSlider" min="1" max="10" step="1" value="3">
            </div>

            <div id="searchStatus"></div>
            <div id="results"></div>
        </div>

        <div class="panel">
            <h2>Statistics</h2>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-value" id="statDocs">0</div>
                    <div class="stat-label">Documents</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="statChunks">0</div>
                    <div class="stat-label">Chunks</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="statQueries">0</div>
                    <div class="stat-label">Queries</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class RAGKnowledgeBase {
            constructor() {
                this.apiKey = localStorage.getItem('openai_api_key') || '';
                this.documents = [];
                this.chunks = [];
                this.embeddings = [];
                this.queryCount = 0;

                this.loadFromStorage();
                this.updateUI();
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.getElementById('alphaSlider').addEventListener('input', (e) => {
                    document.getElementById('alphaValue').textContent = e.target.value;
                });

                document.getElementById('maxResultsSlider').addEventListener('input', (e) => {
                    document.getElementById('maxResultsValue').textContent = e.target.value;
                });

                document.getElementById('queryInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.search();
                });
            }

            saveApiKey() {
                const apiKey = document.getElementById('apiKey').value.trim();
                if (!apiKey) {
                    this.showStatus('addStatus', 'Please enter an API key', 'error');
                    return;
                }
                this.apiKey = apiKey;
                localStorage.setItem('openai_api_key', apiKey);
                this.showStatus('addStatus', 'API key saved successfully', 'success');
                document.getElementById('apiKey').value = '';
            }

            async addDocument() {
                const text = document.getElementById('documentText').value.trim();
                const source = document.getElementById('documentSource').value.trim() || 'Untitled Document';

                if (!text) {
                    this.showStatus('addStatus', 'Please enter document text', 'error');
                    return;
                }

                if (!this.apiKey) {
                    this.showStatus('addStatus', 'Please set your OpenAI API key first', 'error');
                    return;
                }

                document.getElementById('addDocBtn').disabled = true;
                this.showStatus('addStatus', 'Processing document...', 'status');

                try {
                    // Chunk the document
                    const chunks = this.chunkText(text, 500, 50);

                    // Get embeddings for each chunk
                    for (let i = 0; i < chunks.length; i++) {
                        this.showStatus('addStatus', `Embedding chunk ${i + 1}/${chunks.length}...`, 'status');
                        const embedding = await this.getEmbedding(chunks[i]);

                        this.chunks.push({
                            text: chunks[i],
                            source: source,
                            chunkIndex: i
                        });

                        this.embeddings.push(embedding);
                    }

                    this.documents.push({
                        source: source,
                        text: text,
                        chunkCount: chunks.length,
                        timestamp: new Date().toISOString()
                    });

                    this.saveToStorage();
                    this.updateUI();

                    document.getElementById('documentText').value = '';
                    document.getElementById('documentSource').value = '';
                    this.showStatus('addStatus', `Successfully added ${chunks.length} chunks from "${source}"`, 'success');

                } catch (error) {
                    this.showStatus('addStatus', `Error: ${error.message}`, 'error');
                } finally {
                    document.getElementById('addDocBtn').disabled = false;
                }
            }

            chunkText(text, chunkSize, overlap) {
                const words = text.split(/\s+/);
                const chunks = [];

                for (let i = 0; i < words.length; i += chunkSize - overlap) {
                    const chunk = words.slice(i, i + chunkSize).join(' ');
                    if (chunk.length > 0) {
                        chunks.push(chunk);
                    }
                }

                return chunks;
            }

            async getEmbedding(text) {
                const response = await fetch('https://api.openai.com/v1/embeddings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${this.apiKey}`
                    },
                    body: JSON.stringify({
                        input: text,
                        model: 'text-embedding-3-small'
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error?.message || 'Failed to get embedding');
                }

                const data = await response.json();
                return data.data[0].embedding;
            }

            async search() {
                const query = document.getElementById('queryInput').value.trim();
                const alpha = parseFloat(document.getElementById('alphaSlider').value);
                const maxResults = parseInt(document.getElementById('maxResultsSlider').value);

                if (!query) {
                    this.showStatus('searchStatus', 'Please enter a search query', 'error');
                    return;
                }

                if (this.chunks.length === 0) {
                    this.showStatus('searchStatus', 'No documents in knowledge base', 'error');
                    return;
                }

                document.getElementById('searchBtn').disabled = true;
                this.showStatus('searchStatus', 'Searching...', 'status');

                try {
                    // Get query embedding
                    const queryEmbedding = await this.getEmbedding(query);

                    // Calculate hybrid scores
                    const results = this.chunks.map((chunk, idx) => {
                        const vectorScore = this.cosineSimilarity(queryEmbedding, this.embeddings[idx]);
                        const keywordScore = this.keywordSimilarity(query, chunk.text);
                        const hybridScore = alpha * vectorScore + (1 - alpha) * keywordScore;

                        return {
                            chunk,
                            vectorScore,
                            keywordScore,
                            hybridScore
                        };
                    });

                    // Sort by hybrid score and take top results
                    results.sort((a, b) => b.hybridScore - a.hybridScore);
                    const topResults = results.slice(0, maxResults);

                    this.displayResults(topResults, alpha);
                    this.queryCount++;
                    this.updateStats();

                    this.showStatus('searchStatus', `Found ${topResults.length} relevant results`, 'success');

                } catch (error) {
                    this.showStatus('searchStatus', `Error: ${error.message}`, 'error');
                } finally {
                    document.getElementById('searchBtn').disabled = false;
                }
            }

            cosineSimilarity(a, b) {
                let dotProduct = 0;
                let normA = 0;
                let normB = 0;

                for (let i = 0; i < a.length; i++) {
                    dotProduct += a[i] * b[i];
                    normA += a[i] * a[i];
                    normB += b[i] * b[i];
                }

                return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
            }

            keywordSimilarity(query, text) {
                const queryWords = query.toLowerCase().split(/\s+/);
                const textWords = text.toLowerCase().split(/\s+/);

                const matches = queryWords.filter(word =>
                    textWords.some(textWord => textWord.includes(word) || word.includes(textWord))
                );

                return matches.length / queryWords.length;
            }

            displayResults(results, alpha) {
                const container = document.getElementById('results');
                container.innerHTML = '';

                results.forEach((result, idx) => {
                    const div = document.createElement('div');
                    div.className = 'result';
                    div.innerHTML = `
                        <div class="result-score">
                            Rank #${idx + 1} | Hybrid: ${result.hybridScore.toFixed(3)}
                            (Vector: ${result.vectorScore.toFixed(3)}, Keyword: ${result.keywordScore.toFixed(3)})
                        </div>
                        <div class="result-content">${result.chunk.text}</div>
                        <div class="result-source">Source: ${result.chunk.source} (Chunk ${result.chunk.chunkIndex + 1})</div>
                    `;
                    container.appendChild(div);
                });
            }

            updateUI() {
                const list = document.getElementById('documentsList');
                list.innerHTML = '';

                this.documents.forEach((doc, idx) => {
                    const div = document.createElement('div');
                    div.className = 'document-item';
                    div.innerHTML = `
                        <span>${doc.source} (${doc.chunkCount} chunks)</span>
                        <button onclick="app.removeDocument(${idx})" style="padding: 6px 12px; font-size: 12px;">Remove</button>
                    `;
                    list.appendChild(div);
                });

                document.getElementById('docCount').textContent = this.documents.length;
                this.updateStats();
            }

            updateStats() {
                document.getElementById('statDocs').textContent = this.documents.length;
                document.getElementById('statChunks').textContent = this.chunks.length;
                document.getElementById('statQueries').textContent = this.queryCount;
            }

            removeDocument(idx) {
                const doc = this.documents[idx];

                // Find and remove chunks and embeddings
                let removedCount = 0;
                for (let i = this.chunks.length - 1; i >= 0; i--) {
                    if (this.chunks[i].source === doc.source) {
                        this.chunks.splice(i, 1);
                        this.embeddings.splice(i, 1);
                        removedCount++;
                    }
                }

                this.documents.splice(idx, 1);
                this.saveToStorage();
                this.updateUI();

                this.showStatus('addStatus', `Removed document and ${removedCount} chunks`, 'success');
            }

            saveToStorage() {
                localStorage.setItem('rag_documents', JSON.stringify(this.documents));
                localStorage.setItem('rag_chunks', JSON.stringify(this.chunks));
                localStorage.setItem('rag_embeddings', JSON.stringify(this.embeddings));
            }

            loadFromStorage() {
                try {
                    const docs = localStorage.getItem('rag_documents');
                    const chunks = localStorage.getItem('rag_chunks');
                    const embeddings = localStorage.getItem('rag_embeddings');

                    if (docs) this.documents = JSON.parse(docs);
                    if (chunks) this.chunks = JSON.parse(chunks);
                    if (embeddings) this.embeddings = JSON.parse(embeddings);
                } catch (error) {
                    console.error('Failed to load from storage:', error);
                }
            }

            showStatus(elementId, message, type) {
                const element = document.getElementById(elementId);
                element.textContent = message;
                element.className = `status ${type}`;
                element.style.display = 'block';

                if (type !== 'status') {
                    setTimeout(() => {
                        element.style.display = 'none';
                    }, 5000);
                }
            }
        }

        let app;
        window.addEventListener('DOMContentLoaded', () => {
            app = new RAGKnowledgeBase();
        });
    </script>
</body>
</html>
