<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Image Filter Studio</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0f1419;
            --accent-1: #6c5ce7;
            --accent-2: #00d2ff;
            --accent-3: #a8e6cf;
            --text-primary: #ffffff;
            --text-secondary: #b4b4b4;
            --border: #2d3748;
            --shadow: rgba(0, 0, 0, 0.5);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-tertiary) 100%);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        .app-container {
            display: grid;
            grid-template-columns: 300px 1fr 320px;
            grid-template-rows: 60px 1fr 50px;
            height: 100vh;
            gap: 0;
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            background: linear-gradient(90deg, var(--bg-secondary), var(--bg-primary));
            border-bottom: 2px solid var(--accent-1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: 0 4px 6px var(--shadow);
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-1), var(--accent-2));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-actions {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, var(--accent-1), var(--accent-2));
            color: white;
            box-shadow: 0 2px 4px var(--shadow);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px var(--shadow);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
        }

        .btn-icon {
            padding: 8px 12px;
            font-size: 18px;
        }

        /* Sidebar Left - Filters */
        .sidebar-left {
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            padding: 20px;
        }

        /* Main Canvas Area */
        .canvas-area {
            background: var(--bg-tertiary);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #glCanvas {
            max-width: 100%;
            max-height: 100%;
            cursor: grab;
            box-shadow: 0 8px 32px var(--shadow);
        }

        #glCanvas:active {
            cursor: grabbing;
        }

        .canvas-overlay {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            pointer-events: none;
        }

        .canvas-overlay > * {
            pointer-events: auto;
        }

        .zoom-controls {
            display: flex;
            gap: 5px;
            background: rgba(26, 26, 46, 0.9);
            padding: 8px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        /* Sidebar Right - Controls */
        .sidebar-right {
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            padding: 20px;
        }

        /* Section Styling */
        .section {
            margin-bottom: 25px;
        }

        .section-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--accent-2);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .filter-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .filter-btn {
            padding: 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--text-primary);
            font-size: 13px;
            text-align: center;
        }

        .filter-btn:hover {
            background: var(--accent-1);
            border-color: var(--accent-1);
            transform: translateY(-2px);
        }

        .filter-btn.active {
            background: linear-gradient(135deg, var(--accent-1), var(--accent-2));
            border-color: var(--accent-2);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .control-value {
            color: var(--accent-2);
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--bg-tertiary);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-1), var(--accent-2));
            cursor: pointer;
            box-shadow: 0 2px 4px var(--shadow);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-1), var(--accent-2));
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px var(--shadow);
        }

        /* Layer System */
        .layer-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
        }

        .layer-item.active {
            border-color: var(--accent-1);
            background: rgba(108, 92, 231, 0.1);
        }

        .layer-info {
            flex: 1;
        }

        .layer-name {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .layer-params {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .layer-actions {
            display: flex;
            gap: 5px;
        }

        .layer-btn {
            padding: 4px 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: var(--text-primary);
        }

        .layer-btn:hover {
            background: var(--accent-1);
        }

        /* Upload Area */
        .upload-area {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-tertiary);
            z-index: 50;
        }

        .upload-area.hidden {
            display: none;
        }

        .upload-area.dragover {
            background: rgba(108, 92, 231, 0.1);
            border: 3px dashed var(--accent-1);
        }

        .upload-icon {
            font-size: 80px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .upload-text {
            font-size: 24px;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .upload-subtext {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 20px;
        }

        #fileInput {
            display: none;
        }

        /* Histogram */
        .histogram-canvas {
            width: 100%;
            height: 120px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            margin-top: 10px;
        }

        /* Comparison Slider */
        .comparison-slider {
            position: absolute;
            top: 0;
            left: 50%;
            width: 3px;
            height: 100%;
            background: var(--accent-2);
            cursor: ew-resize;
            z-index: 10;
            box-shadow: 0 0 10px var(--accent-2);
        }

        .comparison-slider::before {
            content: '‚ü∑';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--accent-2);
            color: var(--bg-primary);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .comparison-slider.hidden {
            display: none;
        }

        /* Footer */
        .footer {
            grid-column: 1 / -1;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .footer-info {
            display: flex;
            gap: 20px;
        }

        /* Presets */
        .preset-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        .preset-btn {
            padding: 12px;
            background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-secondary));
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--text-primary);
            font-size: 13px;
            text-align: left;
        }

        .preset-btn:hover {
            background: linear-gradient(135deg, var(--accent-1), var(--accent-2));
            border-color: var(--accent-2);
            transform: translateX(5px);
        }

        .preset-name {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .preset-desc {
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* Crop Tool */
        .crop-overlay {
            position: absolute;
            border: 2px dashed var(--accent-2);
            pointer-events: none;
            display: none;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
        }

        .crop-overlay.active {
            display: block;
        }

        .crop-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--accent-2);
            border: 2px solid var(--bg-primary);
            border-radius: 50%;
            pointer-events: auto;
            cursor: pointer;
        }

        .crop-handle.nw { top: -6px; left: -6px; cursor: nw-resize; }
        .crop-handle.ne { top: -6px; right: -6px; cursor: ne-resize; }
        .crop-handle.sw { bottom: -6px; left: -6px; cursor: sw-resize; }
        .crop-handle.se { bottom: -6px; right: -6px; cursor: se-resize; }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent-1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-2);
        }

        /* Loading Spinner */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            border: 4px solid var(--bg-secondary);
            border-top: 4px solid var(--accent-1);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: none;
        }

        .loading.active {
            display: block;
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* Transform Controls */
        .transform-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .transform-btn {
            padding: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--text-primary);
            font-size: 20px;
            text-align: center;
        }

        .transform-btn:hover {
            background: var(--accent-1);
            transform: scale(1.1);
        }

        .color-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .color-btn {
            padding: 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .color-btn:hover {
            background: var(--accent-1);
        }

        /* Mobile responsive styles */
        @media (max-width: 768px) {
            .app-container {
                grid-template-columns: 1fr;
                grid-template-rows: 60px 1fr 60px;
            }

            .header {
                padding: 0 10px;
            }

            .logo {
                font-size: 18px;
                gap: 8px;
            }

            .btn {
                padding: 6px 12px;
                font-size: 12px;
            }

            .sidebar {
                position: fixed;
                left: -100%;
                top: 60px;
                bottom: 60px;
                width: 280px;
                z-index: 200;
                transition: left 0.3s ease;
                box-shadow: 4px 0 10px rgba(0,0,0,0.3);
            }

            .sidebar.active {
                left: 0;
            }

            .controls-panel {
                position: fixed;
                right: -100%;
                top: 60px;
                bottom: 60px;
                width: 300px;
                z-index: 200;
                transition: right 0.3s ease;
                box-shadow: -4px 0 10px rgba(0,0,0,0.3);
            }

            .controls-panel.active {
                right: 0;
            }

            .canvas-area {
                grid-column: 1;
                grid-row: 2;
            }

            .statusbar {
                grid-column: 1;
                font-size: 11px;
                padding: 0 10px;
            }

            .filters-grid {
                grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            }

            .control-group {
                padding: 10px;
            }
        }

        @media (max-width: 480px) {
            .logo {
                font-size: 16px;
            }

            .header-actions {
                gap: 5px;
            }

            .btn {
                padding: 4px 8px;
                font-size: 11px;
            }

            .sidebar,
            .controls-panel {
                width: 100%;
                max-width: 100%;
            }

            .filters-grid {
                grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
                gap: 8px;
            }

            .filter-btn {
                padding: 6px;
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <div class="header">
            <div class="logo">
                <span>üé®</span>
                <span>Image Filter Studio</span>
            </div>
            <div class="header-actions">
                <button class="btn btn-secondary btn-icon" onclick="undo()" title="Undo">‚Ü∂</button>
                <button class="btn btn-secondary btn-icon" onclick="redo()" title="Redo">‚Ü∑</button>
                <button class="btn btn-secondary" onclick="resetImage()">Reset</button>
                <button class="btn" onclick="exportImage()">Export</button>
            </div>
        </div>

        <!-- Left Sidebar - Filters -->
        <div class="sidebar-left">
            <div class="section">
                <div class="section-title">üìÅ File</div>
                <button class="btn" onclick="document.getElementById('fileInput').click()" style="width: 100%;">
                    Upload Image
                </button>
                <input type="file" id="fileInput" accept="image/*" onchange="handleFileUpload(event)">
            </div>

            <div class="section">
                <div class="section-title">‚ú® Presets</div>
                <div class="preset-grid">
                    <div class="preset-btn" onclick="applyPreset('vintage')">
                        <div class="preset-name">Vintage</div>
                        <div class="preset-desc">Warm, nostalgic tone</div>
                    </div>
                    <div class="preset-btn" onclick="applyPreset('bw')">
                        <div class="preset-name">Black & White</div>
                        <div class="preset-desc">Classic monochrome</div>
                    </div>
                    <div class="preset-btn" onclick="applyPreset('cinematic')">
                        <div class="preset-name">Cinematic</div>
                        <div class="preset-desc">Film-like quality</div>
                    </div>
                    <div class="preset-btn" onclick="applyPreset('vibrant')">
                        <div class="preset-name">Vibrant</div>
                        <div class="preset-desc">Enhanced colors</div>
                    </div>
                    <div class="preset-btn" onclick="applyPreset('cool')">
                        <div class="preset-name">Cool Tone</div>
                        <div class="preset-desc">Blue tinted mood</div>
                    </div>
                    <div class="preset-btn" onclick="applyPreset('warm')">
                        <div class="preset-name">Warm Tone</div>
                        <div class="preset-desc">Golden hour feel</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">üé® Filters</div>
                <div class="filter-grid">
                    <div class="filter-btn" onclick="selectFilter('brightness', this)">Brightness</div>
                    <div class="filter-btn" onclick="selectFilter('contrast', this)">Contrast</div>
                    <div class="filter-btn" onclick="selectFilter('saturation', this)">Saturation</div>
                    <div class="filter-btn" onclick="selectFilter('blur', this)">Blur</div>
                    <div class="filter-btn" onclick="selectFilter('sharpen', this)">Sharpen</div>
                    <div class="filter-btn" onclick="selectFilter('grayscale', this)">Grayscale</div>
                    <div class="filter-btn" onclick="selectFilter('sepia', this)">Sepia</div>
                    <div class="filter-btn" onclick="selectFilter('vignette', this)">Vignette</div>
                    <div class="filter-btn" onclick="selectFilter('pixelate', this)">Pixelate</div>
                    <div class="filter-btn" onclick="selectFilter('edge', this)">Edge Detect</div>
                    <div class="filter-btn" onclick="selectFilter('emboss', this)">Emboss</div>
                    <div class="filter-btn" onclick="selectFilter('oil', this)">Oil Paint</div>
                    <div class="filter-btn" onclick="selectFilter('hue', this)">Hue Shift</div>
                    <div class="filter-btn" onclick="selectFilter('exposure', this)">Exposure</div>
                    <div class="filter-btn" onclick="selectFilter('gamma', this)">Gamma</div>
                    <div class="filter-btn" onclick="selectFilter('noise', this)">Noise</div>
                </div>
            </div>
        </div>

        <!-- Main Canvas Area -->
        <div class="canvas-area">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">üñºÔ∏è</div>
                <div class="upload-text">Drop an image here</div>
                <div class="upload-subtext">or click to browse</div>
                <button class="btn" onclick="document.getElementById('fileInput').click()">
                    Choose Image
                </button>
            </div>
            <canvas id="glCanvas"></canvas>
            <div class="comparison-slider hidden" id="comparisonSlider"></div>
            <div class="crop-overlay" id="cropOverlay">
                <div class="crop-handle nw"></div>
                <div class="crop-handle ne"></div>
                <div class="crop-handle sw"></div>
                <div class="crop-handle se"></div>
            </div>
            <div class="canvas-overlay">
                <div class="zoom-controls">
                    <button class="btn btn-secondary btn-icon" onclick="zoomOut()">‚àí</button>
                    <button class="btn btn-secondary btn-icon" onclick="resetZoom()">‚äô</button>
                    <button class="btn btn-secondary btn-icon" onclick="zoomIn()">+</button>
                </div>
                <button class="btn btn-secondary" onclick="toggleComparison()">Compare</button>
            </div>
            <div class="loading" id="loading"></div>
        </div>

        <!-- Right Sidebar - Controls -->
        <div class="sidebar-right">
            <div class="section">
                <div class="section-title">üîß Transform</div>
                <div class="transform-grid">
                    <div class="transform-btn" onclick="rotateLeft()" title="Rotate Left">‚Ü∂</div>
                    <div class="transform-btn" onclick="rotateRight()" title="Rotate Right">‚Ü∑</div>
                    <div class="transform-btn" onclick="flipHorizontal()" title="Flip Horizontal">‚áÑ</div>
                    <div class="transform-btn" onclick="flipVertical()" title="Flip Vertical">‚áÖ</div>
                    <div class="transform-btn" onclick="toggleCropMode()" title="Crop">‚úÇÔ∏è</div>
                    <div class="transform-btn" onclick="fitToCanvas()" title="Fit">‚ä°</div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">‚öôÔ∏è Filter Controls</div>
                <div id="filterControls">
                    <div class="control-group">
                        <div class="control-label">
                            <span>Filter Strength</span>
                            <span class="control-value" id="strengthValue">100%</span>
                        </div>
                        <input type="range" id="strengthSlider" min="0" max="100" value="100"
                               oninput="updateStrength(this.value)">
                    </div>
                    <p style="color: var(--text-secondary); font-size: 13px; margin-top: 10px;">
                        Select a filter to adjust parameters
                    </p>
                </div>
            </div>

            <div class="section">
                <div class="section-title">üéöÔ∏è Quick Adjustments</div>
                <div class="color-controls">
                    <button class="color-btn" onclick="autoEnhance()">Auto Enhance</button>
                    <button class="color-btn" onclick="autoContrast()">Auto Contrast</button>
                    <button class="color-btn" onclick="autoLevel()">Auto Level</button>
                    <button class="color-btn" onclick="normalizeColors()">Normalize</button>
                </div>
            </div>

            <div class="section">
                <div class="section-title">üìä Layers</div>
                <div id="layersList">
                    <p style="color: var(--text-secondary); font-size: 13px;">
                        No layers yet. Apply filters to create layers.
                    </p>
                </div>
                <button class="btn btn-secondary" onclick="clearAllLayers()" style="width: 100%; margin-top: 10px;">
                    Clear All Layers
                </button>
            </div>

            <div class="section">
                <div class="section-title">üìà Histogram</div>
                <canvas id="histogramCanvas" class="histogram-canvas"></canvas>
            </div>
        </div>

        <!-- Footer -->
        <div class="footer">
            <div class="footer-info">
                <span id="imageDimensions">No image loaded</span>
                <span id="zoomLevel">Zoom: 100%</span>
            </div>
            <div>WebGL Image Filter Studio v1.0</div>
        </div>
    </div>

    <script>
        // Global State
        let gl, canvas;
        let originalImage = null;
        let currentTexture = null;
        let workingTexture = null;
        let previewBaseTexture = null; // Texture before preview
        let originalTexture = null;
        let comparisonSplit = 0.5;
        let framebuffer = null;
        let shaderPrograms = {};
        let layers = [];
        let history = [];
        let historyIndex = -1;
        let currentFilter = null;
        let filterParams = {};
        let isPreviewing = false; // Track if we're in preview mode
        let zoom = 1;
        let panX = 0, panY = 0;
        let isDragging = false;
        let dragStartX = 0, dragStartY = 0;
        let rotation = 0;
        let flipH = false, flipV = false;
        let compareMode = false;
        let cropMode = false;
        let cropRect = { x: 0, y: 0, width: 0, height: 0 };

        // Vertex shader
        const vertexShaderSource = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            varying vec2 v_texCoord;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = a_texCoord;
            }
        `;

        // Fragment shaders for different filters
        const fragmentShaders = {
            base: `
                precision mediump float;
                uniform sampler2D u_image;
                varying vec2 v_texCoord;
                void main() {
                    gl_FragColor = texture2D(u_image, v_texCoord);
                }
            `,
            brightness: `
                precision mediump float;
                uniform sampler2D u_image;
                uniform float u_brightness;
                uniform float u_strength;
                varying vec2 v_texCoord;
                void main() {
                    vec4 color = texture2D(u_image, v_texCoord);
                    vec4 adjusted = vec4(color.rgb + u_brightness, color.a);
                    gl_FragColor = mix(color, adjusted, u_strength);
                }
            `,
            contrast: `
                precision mediump float;
                uniform sampler2D u_image;
                uniform float u_contrast;
                uniform float u_strength;
                varying vec2 v_texCoord;
                void main() {
                    vec4 color = texture2D(u_image, v_texCoord);
                    vec3 adjusted = (color.rgb - 0.5) * u_contrast + 0.5;
                    gl_FragColor = mix(color, vec4(adjusted, color.a), u_strength);
                }
            `,
            saturation: `
                precision mediump float;
                uniform sampler2D u_image;
                uniform float u_saturation;
                uniform float u_strength;
                varying vec2 v_texCoord;
                void main() {
                    vec4 color = texture2D(u_image, v_texCoord);
                    float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                    vec3 adjusted = mix(vec3(gray), color.rgb, u_saturation);
                    gl_FragColor = mix(color, vec4(adjusted, color.a), u_strength);
                }
            `,
            blur: `
                precision mediump float;
                uniform sampler2D u_image;
                uniform vec2 u_resolution;
                uniform float u_blurAmount;
                uniform float u_strength;
                varying vec2 v_texCoord;
                void main() {
                    vec4 color = vec4(0.0);
                    vec2 off = u_blurAmount / u_resolution;
                    color += texture2D(u_image, v_texCoord + vec2(-off.x, -off.y)) * 0.0625;
                    color += texture2D(u_image, v_texCoord + vec2(0.0, -off.y)) * 0.125;
                    color += texture2D(u_image, v_texCoord + vec2(off.x, -off.y)) * 0.0625;
                    color += texture2D(u_image, v_texCoord + vec2(-off.x, 0.0)) * 0.125;
                    color += texture2D(u_image, v_texCoord) * 0.25;
                    color += texture2D(u_image, v_texCoord + vec2(off.x, 0.0)) * 0.125;
                    color += texture2D(u_image, v_texCoord + vec2(-off.x, off.y)) * 0.0625;
                    color += texture2D(u_image, v_texCoord + vec2(0.0, off.y)) * 0.125;
                    color += texture2D(u_image, v_texCoord + vec2(off.x, off.y)) * 0.0625;
                    vec4 original = texture2D(u_image, v_texCoord);
                    gl_FragColor = mix(original, color, u_strength);
                }
            `,
            sharpen: `
                precision mediump float;
                uniform sampler2D u_image;
                uniform vec2 u_resolution;
                uniform float u_amount;
                uniform float u_strength;
                varying vec2 v_texCoord;
                void main() {
                    vec2 step = 1.0 / u_resolution;
                    vec4 color = texture2D(u_image, v_texCoord);
                    vec4 up = texture2D(u_image, v_texCoord + vec2(0.0, -step.y));
                    vec4 down = texture2D(u_image, v_texCoord + vec2(0.0, step.y));
                    vec4 left = texture2D(u_image, v_texCoord + vec2(-step.x, 0.0));
                    vec4 right = texture2D(u_image, v_texCoord + vec2(step.x, 0.0));
                    vec4 laplacian = -up - down - left - right + 4.0 * color;
                    vec4 sharpened = color + laplacian * u_amount;
                    gl_FragColor = mix(color, sharpened, u_strength);
                }
            `,
            grayscale: `
                precision mediump float;
                uniform sampler2D u_image;
                uniform float u_strength;
                varying vec2 v_texCoord;
                void main() {
                    vec4 color = texture2D(u_image, v_texCoord);
                    float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                    vec4 grayColor = vec4(vec3(gray), color.a);
                    gl_FragColor = mix(color, grayColor, u_strength);
                }
            `,
            sepia: `
                precision mediump float;
                uniform sampler2D u_image;
                uniform float u_strength;
                varying vec2 v_texCoord;
                void main() {
                    vec4 color = texture2D(u_image, v_texCoord);
                    vec3 sepia;
                    sepia.r = dot(color.rgb, vec3(0.393, 0.769, 0.189));
                    sepia.g = dot(color.rgb, vec3(0.349, 0.686, 0.168));
                    sepia.b = dot(color.rgb, vec3(0.272, 0.534, 0.131));
                    gl_FragColor = mix(color, vec4(sepia, color.a), u_strength);
                }
            `,
            vignette: `
                precision mediump float;
                uniform sampler2D u_image;
                uniform float u_amount;
                uniform float u_strength;
                varying vec2 v_texCoord;
                void main() {
                    vec4 color = texture2D(u_image, v_texCoord);
                    vec2 pos = v_texCoord - 0.5;
                    float dist = length(pos);
                    float vignette = smoothstep(0.8, 0.2, dist * u_amount);
                    vec4 vignetted = vec4(color.rgb * vignette, color.a);
                    gl_FragColor = mix(color, vignetted, u_strength);
                }
            `,
            pixelate: `
                precision mediump float;
                uniform sampler2D u_image;
                uniform vec2 u_resolution;
                uniform float u_pixelSize;
                uniform float u_strength;
                varying vec2 v_texCoord;
                void main() {
                    vec2 pixelSize = vec2(u_pixelSize) / u_resolution;
                    vec2 coord = floor(v_texCoord / pixelSize) * pixelSize;
                    vec4 pixelated = texture2D(u_image, coord);
                    vec4 original = texture2D(u_image, v_texCoord);
                    gl_FragColor = mix(original, pixelated, u_strength);
                }
            `,
            edge: `
                precision mediump float;
                uniform sampler2D u_image;
                uniform vec2 u_resolution;
                uniform float u_strength;
                varying vec2 v_texCoord;
                void main() {
                    vec2 step = 1.0 / u_resolution;
                    vec4 color = texture2D(u_image, v_texCoord);
                    float edge = 0.0;
                    for(int i = -1; i <= 1; i++) {
                        for(int j = -1; j <= 1; j++) {
                            vec4 c = texture2D(u_image, v_texCoord + vec2(float(i), float(j)) * step);
                            float gray = dot(c.rgb, vec3(0.299, 0.587, 0.114));
                            edge += gray * (float(i == 0 && j == 0) * 8.0 - 1.0);
                        }
                    }
                    edge = abs(edge);
                    vec4 edgeColor = vec4(vec3(edge), color.a);
                    gl_FragColor = mix(color, edgeColor, u_strength);
                }
            `,
            emboss: `
                precision mediump float;
                uniform sampler2D u_image;
                uniform vec2 u_resolution;
                uniform float u_strength;
                varying vec2 v_texCoord;
                void main() {
                    vec2 step = 1.0 / u_resolution;
                    vec4 color = texture2D(u_image, v_texCoord);
                    vec4 tl = texture2D(u_image, v_texCoord + vec2(-step.x, -step.y));
                    vec4 br = texture2D(u_image, v_texCoord + vec2(step.x, step.y));
                    vec4 emboss = (tl - br) + 0.5;
                    gl_FragColor = mix(color, emboss, u_strength);
                }
            `,
            oil: `
                precision mediump float;
                uniform sampler2D u_image;
                uniform vec2 u_resolution;
                uniform float u_radius;
                uniform float u_strength;
                varying vec2 v_texCoord;
                void main() {
                    vec4 color = texture2D(u_image, v_texCoord);
                    vec3 m[4];
                    vec3 s[4];
                    for (int k = 0; k < 4; ++k) {
                        m[k] = vec3(0.0);
                        s[k] = vec3(0.0);
                    }
                    vec2 step = u_radius / u_resolution;
                    for (float j = -3.0; j <= 3.0; ++j) {
                        for (float i = -3.0; i <= 3.0; ++i) {
                            vec3 c = texture2D(u_image, v_texCoord + vec2(i, j) * step).rgb;
                            int k = int(dot(c, vec3(0.25)));
                            k = clamp(k, 0, 3);
                            m[k] += c;
                            s[k] += c * c;
                        }
                    }
                    float minSigma = 1e10;
                    vec3 result = color.rgb;
                    for (int k = 0; k < 4; ++k) {
                        m[k] /= 49.0;
                        s[k] = abs(s[k] / 49.0 - m[k] * m[k]);
                        float sigma = s[k].r + s[k].g + s[k].b;
                        if (sigma < minSigma) {
                            minSigma = sigma;
                            result = m[k];
                        }
                    }
                    gl_FragColor = mix(color, vec4(result, color.a), u_strength);
                }
            `,
            hue: `
                precision mediump float;
                uniform sampler2D u_image;
                uniform float u_hue;
                uniform float u_strength;
                varying vec2 v_texCoord;
                vec3 rgb2hsv(vec3 c) {
                    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
                    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
                    float d = q.x - min(q.w, q.y);
                    float e = 1.0e-10;
                    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
                }
                vec3 hsv2rgb(vec3 c) {
                    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                }
                void main() {
                    vec4 color = texture2D(u_image, v_texCoord);
                    vec3 hsv = rgb2hsv(color.rgb);
                    hsv.x = fract(hsv.x + u_hue);
                    vec3 rgb = hsv2rgb(hsv);
                    gl_FragColor = mix(color, vec4(rgb, color.a), u_strength);
                }
            `,
            exposure: `
                precision mediump float;
                uniform sampler2D u_image;
                uniform float u_exposure;
                uniform float u_strength;
                varying vec2 v_texCoord;
                void main() {
                    vec4 color = texture2D(u_image, v_texCoord);
                    vec3 exposed = color.rgb * pow(2.0, u_exposure);
                    gl_FragColor = mix(color, vec4(exposed, color.a), u_strength);
                }
            `,
            gamma: `
                precision mediump float;
                uniform sampler2D u_image;
                uniform float u_gamma;
                uniform float u_strength;
                varying vec2 v_texCoord;
                void main() {
                    vec4 color = texture2D(u_image, v_texCoord);
                    vec3 corrected = pow(color.rgb, vec3(1.0 / u_gamma));
                    gl_FragColor = mix(color, vec4(corrected, color.a), u_strength);
                }
            `,
            noise: `
                precision mediump float;
                uniform sampler2D u_image;
                uniform float u_amount;
                uniform float u_strength;
                uniform float u_time;
                varying vec2 v_texCoord;
                float random(vec2 st) {
                    return fract(sin(dot(st.xy + u_time, vec2(12.9898,78.233))) * 43758.5453123);
                }
                void main() {
                    vec4 color = texture2D(u_image, v_texCoord);
                    float noise = (random(v_texCoord) - 0.5) * u_amount;
                    vec4 noisy = vec4(color.rgb + noise, color.a);
                    gl_FragColor = mix(color, noisy, u_strength);
                }
            `
        };

        // Filter parameter definitions
        const filterDefinitions = {
            brightness: { params: [{ name: 'brightness', label: 'Brightness', min: -0.5, max: 0.5, default: 0.1, step: 0.01 }] },
            contrast: { params: [{ name: 'contrast', label: 'Contrast', min: 0.5, max: 2.0, default: 1.3, step: 0.01 }] },
            saturation: { params: [{ name: 'saturation', label: 'Saturation', min: 0, max: 2.0, default: 1.3, step: 0.01 }] },
            blur: { params: [{ name: 'blurAmount', label: 'Blur Amount', min: 0, max: 10, default: 3, step: 0.1 }] },
            sharpen: { params: [{ name: 'amount', label: 'Sharpen Amount', min: 0, max: 2, default: 0.8, step: 0.01 }] },
            grayscale: { params: [] },
            sepia: { params: [] },
            vignette: { params: [{ name: 'amount', label: 'Vignette Amount', min: 0.5, max: 2.0, default: 1.2, step: 0.01 }] },
            pixelate: { params: [{ name: 'pixelSize', label: 'Pixel Size', min: 2, max: 32, default: 8, step: 1 }] },
            edge: { params: [] },
            emboss: { params: [] },
            oil: { params: [{ name: 'radius', label: 'Brush Radius', min: 1, max: 10, default: 4, step: 0.5 }] },
            hue: { params: [{ name: 'hue', label: 'Hue Shift', min: 0, max: 1, default: 0.3, step: 0.01 }] },
            exposure: { params: [{ name: 'exposure', label: 'Exposure', min: -2, max: 2, default: 0.5, step: 0.1 }] },
            gamma: { params: [{ name: 'gamma', label: 'Gamma', min: 0.5, max: 3.0, default: 1.5, step: 0.1 }] },
            noise: { params: [{ name: 'amount', label: 'Noise Amount', min: 0, max: 0.5, default: 0.1, step: 0.01 }] }
        };

        // Initialize WebGL
        function initWebGL() {
            canvas = document.getElementById('glCanvas');
            gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });

            if (!gl) {
                alert('WebGL not supported!');
                return;
            }

            gl.clearColor(0, 0, 0, 0);

            // Create shader programs
            for (const [name, fragmentSource] of Object.entries(fragmentShaders)) {
                shaderPrograms[name] = createProgram(vertexShaderSource, fragmentSource);
            }

            // Create framebuffer for off-screen rendering
            framebuffer = gl.createFramebuffer();

            // Setup upload area drag and drop
            const uploadArea = document.getElementById('uploadArea');
            uploadArea.addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, preventDefaults, false);
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                uploadArea.addEventListener(eventName, () => {
                    uploadArea.classList.add('dragover');
                }, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, () => {
                    uploadArea.classList.remove('dragover');
                }, false);
            });

            uploadArea.addEventListener('drop', handleDrop, false);

            // Setup canvas interactions
            setupCanvasInteractions();

            // Setup comparison slider
            setupComparisonSlider();

            console.log('WebGL initialized successfully');
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            if (files.length > 0) {
                loadImage(files[0]);
            }
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                loadImage(file);
            }
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        function createProgram(vertexSource, fragmentSource) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program linking error:', gl.getProgramInfoLog(program));
                return null;
            }

            return program;
        }

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    initializeImage(img);
                    document.getElementById('uploadArea').classList.add('hidden');
                    updateHistogram();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function initializeImage(img) {
            // Clean up any existing textures to avoid GPU leaks when loading a new image
            const texturesToDispose = new Set();
            [currentTexture, workingTexture, previewBaseTexture, originalTexture].forEach(texture => {
                if (texture) {
                    texturesToDispose.add(texture);
                }
            });
            history.forEach(state => {
                if (state.texture) {
                    texturesToDispose.add(state.texture);
                }
            });
            texturesToDispose.forEach(texture => gl.deleteTexture(texture));

            previewBaseTexture = null;
            isPreviewing = false;

            // Reset comparison state
            compareMode = false;
            comparisonSplit = 0.5;
            const comparisonSlider = document.getElementById('comparisonSlider');
            if (comparisonSlider) {
                comparisonSlider.classList.add('hidden');
                comparisonSlider.style.left = '50%';
            }

            // Set canvas size to image size
            canvas.width = img.width;
            canvas.height = img.height;

            // Create texture from image
            originalTexture = createTexture(img);
            currentTexture = createTexture(img);
            workingTexture = createTexture(img);

            // Reset state
            layers = [];
            history = [{ texture: createTexture(img), layers: [] }];
            historyIndex = 0;
            rotation = 0;
            flipH = false;
            flipV = false;
            zoom = 1;
            panX = 0;
            panY = 0;

            // Update UI
            document.getElementById('imageDimensions').textContent = `${img.width} √ó ${img.height}px`;

            // Render
            render();
            fitToCanvas();
            updateLayersList();
        }

        function createTexture(source) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);

            return texture;
        }

        function setupVertexBuffer() {
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [
                -1, -1,
                1, -1,
                -1, 1,
                1, 1,
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            const texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            const texCoords = [
                0, 1,
                1, 1,
                0, 0,
                1, 0,
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);

            return { positionBuffer, texCoordBuffer };
        }

        function render() {
            if (!currentTexture) return;

            const program = shaderPrograms.base;
            gl.useProgram(program);

            const { positionBuffer, texCoordBuffer } = setupVertexBuffer();

            // Position attribute
            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            // Texture coordinate attribute
            const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.enableVertexAttribArray(texCoordLocation);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

            const imageLocation = gl.getUniformLocation(program, 'u_image');
            gl.uniform1i(imageLocation, 0);

            // Set viewport
            gl.viewport(0, 0, canvas.width, canvas.height);

            const drawSegment = (texture, startRatio = 0, endRatio = 1) => {
                if (!texture) return;

                const clampedStart = Math.max(0, Math.min(1, startRatio));
                const clampedEnd = Math.max(clampedStart, Math.min(1, endRatio));
                const rawWidth = (clampedEnd - clampedStart) * canvas.width;

                if (rawWidth <= 0) {
                    return;
                }

                const startX = Math.max(0, Math.floor(clampedStart * canvas.width));
                const endX = Math.min(canvas.width, Math.ceil(clampedEnd * canvas.width));
                const segmentWidth = Math.max(1, endX - startX);
                gl.enable(gl.SCISSOR_TEST);
                gl.scissor(startX, 0, Math.min(canvas.width - startX, segmentWidth), canvas.height);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                gl.disable(gl.SCISSOR_TEST);
            };

            if (compareMode && originalTexture) {
                gl.disable(gl.SCISSOR_TEST);
                gl.clear(gl.COLOR_BUFFER_BIT);

                // Draw original on the left portion
                if (comparisonSplit > 0) {
                    drawSegment(originalTexture, 0, comparisonSplit);
                }

                // Draw current result on the right portion
                if (comparisonSplit < 1) {
                    drawSegment(currentTexture, comparisonSplit, 1);
                }
            } else {
                gl.disable(gl.SCISSOR_TEST);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, currentTexture);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }

            // Update canvas display size with zoom
            updateCanvasDisplay();
        }

        function updateCanvasDisplay() {
            const containerWidth = canvas.parentElement.clientWidth;
            const containerHeight = canvas.parentElement.clientHeight;

            const scale = Math.min(
                containerWidth / canvas.width,
                containerHeight / canvas.height
            ) * zoom;

            canvas.style.width = (canvas.width * scale) + 'px';
            canvas.style.height = (canvas.height * scale) + 'px';
            canvas.style.transform = `translate(${panX}px, ${panY}px)`;
        }

        function applyFilter(filterName, params, strength = 1.0, isPreview = false) {
            if (!currentTexture || !fragmentShaders[filterName]) return;

            const program = shaderPrograms[filterName];
            gl.useProgram(program);

            // Bind framebuffer for off-screen rendering
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

            // Create a new texture for output
            const outputTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, outputTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

            // Attach texture to framebuffer
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);

            const { positionBuffer, texCoordBuffer } = setupVertexBuffer();

            // Position attribute
            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            // Texture coordinate attribute
            const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.enableVertexAttribArray(texCoordLocation);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

            // Bind input texture - use previewBaseTexture if in preview mode
            const inputTexture = (isPreview && previewBaseTexture) ? previewBaseTexture : currentTexture;
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, inputTexture);
            gl.uniform1i(gl.getUniformLocation(program, 'u_image'), 0);

            // Set filter-specific uniforms
            if (params) {
                for (const [key, value] of Object.entries(params)) {
                    const location = gl.getUniformLocation(program, `u_${key}`);
                    if (location) {
                        gl.uniform1f(location, value);
                    }
                }
            }

            // Set common uniforms
            const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
            if (resolutionLocation) {
                gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            }

            const strengthLocation = gl.getUniformLocation(program, 'u_strength');
            if (strengthLocation) {
                gl.uniform1f(strengthLocation, strength);
            }

            const timeLocation = gl.getUniformLocation(program, 'u_time');
            if (timeLocation) {
                gl.uniform1f(timeLocation, Date.now() / 1000.0);
            }

            // Render to framebuffer
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            // Unbind framebuffer
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            // Clean up old preview texture if in preview mode
            if (isPreview && isPreviewing && currentTexture !== previewBaseTexture) {
                // Don't delete the texture if it's the base or in history
                if (!isTextureInHistory(currentTexture)) {
                    gl.deleteTexture(currentTexture);
                }
            }

            // Update current texture
            currentTexture = outputTexture;

            // Render to screen
            render();

            return outputTexture;
        }

        function isTextureInHistory(texture) {
            return history.some(state => state.texture === texture);
        }

        function selectFilter(filterName, button) {
            if (!filterDefinitions[filterName]) {
                console.warn(`Unknown filter requested: ${filterName}`);
                return;
            }

            if (isPreviewing && previewBaseTexture && currentTexture && currentTexture !== previewBaseTexture) {
                if (!isTextureInHistory(currentTexture)) {
                    gl.deleteTexture(currentTexture);
                }
                currentTexture = previewBaseTexture;
                render();
            }

            currentFilter = filterName;

            // Save current texture as preview base
            previewBaseTexture = currentTexture;
            isPreviewing = true;

            // Update UI
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            if (button) {
                button.classList.add('active');
            }

            // Setup filter controls
            const definition = filterDefinitions[filterName];
            const controlsHTML = `
                <div class="control-group">
                    <div class="control-label">
                        <span>Filter Strength</span>
                        <span class="control-value" id="strengthValue">100%</span>
                    </div>
                    <input type="range" id="strengthSlider" min="0" max="100" value="100"
                           oninput="updateStrength(this.value)">
                </div>
                ${definition.params.map(param => `
                    <div class="control-group">
                        <div class="control-label">
                            <span>${param.label}</span>
                            <span class="control-value" id="${param.name}Value">${param.default}</span>
                        </div>
                        <input type="range" id="${param.name}Slider"
                               min="${param.min}" max="${param.max}"
                               value="${param.default}" step="${param.step}"
                               oninput="updateFilterParam('${param.name}', this.value)">
                    </div>
                `).join('')}
                <button class="btn" onclick="applyCurrentFilter()" style="width: 100%; margin-top: 10px;">
                    Apply Filter
                </button>
            `;

            document.getElementById('filterControls').innerHTML = controlsHTML;

            // Initialize filter params
            filterParams = {};
            definition.params.forEach(param => {
                filterParams[param.name] = param.default;
            });
        }

        function updateFilterParam(paramName, value) {
            filterParams[paramName] = parseFloat(value);
            document.getElementById(`${paramName}Value`).textContent = parseFloat(value).toFixed(2);

            // Preview filter in real-time
            if (currentFilter && previewBaseTexture) {
                const strength = parseFloat(document.getElementById('strengthSlider').value) / 100;
                applyFilter(currentFilter, filterParams, strength, true);
            }
        }

        function updateStrength(value) {
            document.getElementById('strengthValue').textContent = value + '%';

            // Preview with updated strength
            if (currentFilter && previewBaseTexture) {
                const strength = parseFloat(value) / 100;
                applyFilter(currentFilter, filterParams, strength, true);
            }
        }

        function applyCurrentFilter() {
            if (!currentFilter || !currentTexture) return;

            // Exit preview mode
            isPreviewing = false;
            previewBaseTexture = null;

            const strength = parseFloat(document.getElementById('strengthSlider').value) / 100;

            // Add to layers
            layers.push({
                name: currentFilter,
                params: { ...filterParams },
                strength: strength
            });

            // Save to history
            saveHistory();

            // Update UI
            updateLayersList();
            updateHistogram();
        }

        function saveHistory() {
            // Remove any history after current index
            history = history.slice(0, historyIndex + 1);

            // Save current state
            const imageData = new Image();
            imageData.src = canvas.toDataURL();
            imageData.onload = () => {
                const texture = createTexture(imageData);
                history.push({
                    texture: texture,
                    layers: JSON.parse(JSON.stringify(layers))
                });
                historyIndex++;
            };
        }

        function undo() {
            if (historyIndex > 0) {
                // Exit preview mode if active
                isPreviewing = false;
                previewBaseTexture = null;

                historyIndex--;
                const state = history[historyIndex];
                currentTexture = state.texture;
                layers = JSON.parse(JSON.stringify(state.layers));
                render();
                updateLayersList();
                updateHistogram();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                // Exit preview mode if active
                isPreviewing = false;
                previewBaseTexture = null;

                historyIndex++;
                const state = history[historyIndex];
                currentTexture = state.texture;
                layers = JSON.parse(JSON.stringify(state.layers));
                render();
                updateLayersList();
                updateHistogram();
            }
        }

        function resetImage() {
            if (originalImage) {
                // Exit preview mode if active
                isPreviewing = false;
                previewBaseTexture = null;

                initializeImage(originalImage);
            }
        }

        function updateLayersList() {
            const layersList = document.getElementById('layersList');

            if (layers.length === 0) {
                layersList.innerHTML = '<p style="color: var(--text-secondary); font-size: 13px;">No layers yet. Apply filters to create layers.</p>';
                return;
            }

            const html = layers.map((layer, index) => `
                <div class="layer-item" data-index="${index}">
                    <div class="layer-info">
                        <div class="layer-name">${layer.name}</div>
                        <div class="layer-params">Strength: ${(layer.strength * 100).toFixed(0)}%</div>
                    </div>
                    <div class="layer-actions">
                        <button class="layer-btn" onclick="removeLayer(${index})">‚úï</button>
                    </div>
                </div>
            `).join('');

            layersList.innerHTML = html;
        }

        function removeLayer(index) {
            // Exit preview mode if active
            isPreviewing = false;
            previewBaseTexture = null;

            layers.splice(index, 1);

            // Reapply all remaining layers from original image
            currentTexture = createTexture(originalImage);
            layers.forEach(layer => {
                applyFilter(layer.name, layer.params, layer.strength, false);
            });

            saveHistory();
            updateLayersList();
            updateHistogram();
        }

        function clearAllLayers() {
            if (confirm('Clear all layers and reset to original image?')) {
                resetImage();
            }
        }

        // Zoom and Pan
        function zoomIn() {
            zoom = Math.min(zoom * 1.2, 5);
            updateCanvasDisplay();
            document.getElementById('zoomLevel').textContent = `Zoom: ${(zoom * 100).toFixed(0)}%`;
        }

        function zoomOut() {
            zoom = Math.max(zoom / 1.2, 0.1);
            updateCanvasDisplay();
            document.getElementById('zoomLevel').textContent = `Zoom: ${(zoom * 100).toFixed(0)}%`;
        }

        function resetZoom() {
            zoom = 1;
            panX = 0;
            panY = 0;
            updateCanvasDisplay();
            document.getElementById('zoomLevel').textContent = 'Zoom: 100%';
        }

        function fitToCanvas() {
            if (!canvas.width || !canvas.height) return;

            const containerWidth = canvas.parentElement.clientWidth;
            const containerHeight = canvas.parentElement.clientHeight;

            zoom = Math.min(
                containerWidth / canvas.width,
                containerHeight / canvas.height
            ) * 0.9;

            panX = 0;
            panY = 0;
            updateCanvasDisplay();
            document.getElementById('zoomLevel').textContent = `Zoom: ${(zoom * 100).toFixed(0)}%`;
        }

        function setupCanvasInteractions() {
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                dragStartX = e.clientX - panX;
                dragStartY = e.clientY - panY;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    panX = e.clientX - dragStartX;
                    panY = e.clientY - dragStartY;
                    updateCanvasDisplay();
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });

            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                zoom = Math.max(0.1, Math.min(5, zoom * delta));
                updateCanvasDisplay();
                document.getElementById('zoomLevel').textContent = `Zoom: ${(zoom * 100).toFixed(0)}%`;
            });
        }

        // Transform functions
        function rotateLeft() {
            rotation = (rotation - 90) % 360;
            applyTransform();
        }

        function rotateRight() {
            rotation = (rotation + 90) % 360;
            applyTransform();
        }

        function flipHorizontal() {
            flipH = !flipH;
            applyTransform();
        }

        function flipVertical() {
            flipV = !flipV;
            applyTransform();
        }

        function applyTransform() {
            if (!currentTexture) return;

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            // Handle rotation dimensions
            if (rotation % 180 !== 0) {
                tempCanvas.width = canvas.height;
                tempCanvas.height = canvas.width;
            } else {
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
            }

            tempCtx.save();
            tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
            tempCtx.rotate(rotation * Math.PI / 180);
            tempCtx.scale(flipH ? -1 : 1, flipV ? -1 : 1);
            tempCtx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);
            tempCtx.restore();

            // Update canvas and texture
            canvas.width = tempCanvas.width;
            canvas.height = tempCanvas.height;

            const img = new Image();
            img.onload = () => {
                currentTexture = createTexture(img);
                render();
                saveHistory();
            };
            img.src = tempCanvas.toDataURL();
        }

        // Comparison slider
        function toggleComparison() {
            if (!currentTexture || !originalTexture) {
                return;
            }

            compareMode = !compareMode;
            const slider = document.getElementById('comparisonSlider');

            if (compareMode) {
                slider.classList.remove('hidden');
                slider.style.left = `${comparisonSplit * 100}%`;
            } else {
                slider.classList.add('hidden');
            }

            render();
        }

        function setupComparisonSlider() {
            const slider = document.getElementById('comparisonSlider');
            let isSliding = false;

            const updateSplitFromClient = (clientX) => {
                if (!compareMode) return;

                const canvasRect = canvas.getBoundingClientRect();
                if (!canvasRect.width || !canvasRect.height) return;

                const clampedX = Math.min(Math.max(clientX, canvasRect.left), canvasRect.right);
                const ratio = (clampedX - canvasRect.left) / canvasRect.width;
                comparisonSplit = Math.max(0, Math.min(1, ratio));
                slider.style.left = `${comparisonSplit * 100}%`;
                render();
            };

            slider.addEventListener('mousedown', (event) => {
                if (!compareMode) return;
                event.preventDefault();
                isSliding = true;
                updateSplitFromClient(event.clientX);
            });

            document.addEventListener('mousemove', (event) => {
                if (!isSliding || !compareMode) return;
                event.preventDefault();
                updateSplitFromClient(event.clientX);
            });

            document.addEventListener('mouseup', () => {
                isSliding = false;
            });

            slider.addEventListener('touchstart', (event) => {
                if (!compareMode) return;
                event.preventDefault();
                isSliding = true;
                updateSplitFromClient(event.touches[0].clientX);
            }, { passive: false });

            document.addEventListener('touchmove', (event) => {
                if (!isSliding || !compareMode) return;
                event.preventDefault();
                updateSplitFromClient(event.touches[0].clientX);
            }, { passive: false });

            const endTouch = () => {
                isSliding = false;
            };

            document.addEventListener('touchend', endTouch);
            document.addEventListener('touchcancel', endTouch);
        }

        // Histogram
        function updateHistogram() {
            if (!canvas.width || !canvas.height) return;

            const histCanvas = document.getElementById('histogramCanvas');
            const ctx = histCanvas.getContext('2d');
            const width = histCanvas.width = histCanvas.clientWidth;
            const height = histCanvas.height = histCanvas.clientHeight;

            // Make sure we're reading from the main framebuffer
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            // Get image data - FIX: properly allocate buffer for gl.readPixels
            const imageData = new Uint8Array(canvas.width * canvas.height * 4);
            gl.readPixels(0, 0, canvas.width, canvas.height, gl.RGBA, gl.UNSIGNED_BYTE, imageData);

            // Calculate histogram
            const histR = new Array(256).fill(0);
            const histG = new Array(256).fill(0);
            const histB = new Array(256).fill(0);

            // Sample pixels (to improve performance)
            const step = Math.max(1, Math.ceil(canvas.width * canvas.height / 10000));
            for (let i = 0; i < imageData.length; i += step * 4) {
                histR[imageData[i]]++;
                histG[imageData[i + 1]]++;
                histB[imageData[i + 2]]++;
            }

            // Find max value for scaling
            const maxR = Math.max(...histR);
            const maxG = Math.max(...histG);
            const maxB = Math.max(...histB);
            const max = Math.max(maxR, maxG, maxB);

            // Avoid division by zero
            if (max === 0) return;

            // Clear canvas
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-tertiary');
            ctx.fillRect(0, 0, width, height);

            // Draw histograms
            const binWidth = width / 256;

            // Red
            ctx.fillStyle = 'rgba(255, 100, 100, 0.5)';
            for (let i = 0; i < 256; i++) {
                const h = (histR[i] / max) * height;
                ctx.fillRect(i * binWidth, height - h, binWidth, h);
            }

            // Green
            ctx.fillStyle = 'rgba(100, 255, 100, 0.5)';
            for (let i = 0; i < 256; i++) {
                const h = (histG[i] / max) * height;
                ctx.fillRect(i * binWidth, height - h, binWidth, h);
            }

            // Blue
            ctx.fillStyle = 'rgba(100, 100, 255, 0.5)';
            for (let i = 0; i < 256; i++) {
                const h = (histB[i] / max) * height;
                ctx.fillRect(i * binWidth, height - h, binWidth, h);
            }
        }

        // Crop tool
        function toggleCropMode() {
            cropMode = !cropMode;
            const overlay = document.getElementById('cropOverlay');

            if (cropMode) {
                overlay.classList.add('active');
                const rect = canvas.getBoundingClientRect();
                cropRect = {
                    x: rect.width * 0.1,
                    y: rect.height * 0.1,
                    width: rect.width * 0.8,
                    height: rect.height * 0.8
                };
                updateCropOverlay();
            } else {
                overlay.classList.remove('active');
            }
        }

        function updateCropOverlay() {
            const overlay = document.getElementById('cropOverlay');
            overlay.style.left = cropRect.x + 'px';
            overlay.style.top = cropRect.y + 'px';
            overlay.style.width = cropRect.width + 'px';
            overlay.style.height = cropRect.height + 'px';
        }

        // Presets
        function applyPreset(presetName) {
            if (!currentTexture) return;

            // Exit preview mode if active
            isPreviewing = false;
            previewBaseTexture = null;

            // Reset to base image
            currentTexture = history[0].texture;
            layers = [];

            const presets = {
                vintage: [
                    { filter: 'sepia', params: {}, strength: 0.6 },
                    { filter: 'contrast', params: { contrast: 1.2 }, strength: 1.0 },
                    { filter: 'vignette', params: { amount: 1.3 }, strength: 0.8 }
                ],
                bw: [
                    { filter: 'grayscale', params: {}, strength: 1.0 },
                    { filter: 'contrast', params: { contrast: 1.3 }, strength: 1.0 }
                ],
                cinematic: [
                    { filter: 'contrast', params: { contrast: 1.4 }, strength: 1.0 },
                    { filter: 'saturation', params: { saturation: 0.8 }, strength: 1.0 },
                    { filter: 'vignette', params: { amount: 1.5 }, strength: 0.7 }
                ],
                vibrant: [
                    { filter: 'saturation', params: { saturation: 1.6 }, strength: 1.0 },
                    { filter: 'contrast', params: { contrast: 1.2 }, strength: 1.0 },
                    { filter: 'brightness', params: { brightness: 0.05 }, strength: 1.0 }
                ],
                cool: [
                    { filter: 'hue', params: { hue: 0.55 }, strength: 0.3 },
                    { filter: 'saturation', params: { saturation: 1.2 }, strength: 1.0 }
                ],
                warm: [
                    { filter: 'hue', params: { hue: 0.05 }, strength: 0.3 },
                    { filter: 'saturation', params: { saturation: 1.3 }, strength: 1.0 },
                    { filter: 'brightness', params: { brightness: 0.03 }, strength: 1.0 }
                ]
            };

            const preset = presets[presetName];
            if (preset) {
                preset.forEach(({ filter, params, strength }) => {
                    applyFilter(filter, params, strength, false);
                    layers.push({ name: filter, params: params, strength: strength });
                });

                saveHistory();
                updateLayersList();
                updateHistogram();
            }
        }

        // Auto adjustments
        function autoEnhance() {
            if (!currentTexture) return;

            // Exit preview mode if active
            isPreviewing = false;
            previewBaseTexture = null;

            applyFilter('contrast', { contrast: 1.2 }, 1.0, false);
            layers.push({ name: 'contrast', params: { contrast: 1.2 }, strength: 1.0 });

            applyFilter('saturation', { saturation: 1.15 }, 1.0, false);
            layers.push({ name: 'saturation', params: { saturation: 1.15 }, strength: 1.0 });

            saveHistory();
            updateLayersList();
            updateHistogram();
        }

        function autoContrast() {
            if (!currentTexture) return;

            // Exit preview mode if active
            isPreviewing = false;
            previewBaseTexture = null;

            applyFilter('contrast', { contrast: 1.3 }, 1.0, false);
            layers.push({ name: 'contrast', params: { contrast: 1.3 }, strength: 1.0 });

            saveHistory();
            updateLayersList();
            updateHistogram();
        }

        function autoLevel() {
            if (!currentTexture) return;

            // Exit preview mode if active
            isPreviewing = false;
            previewBaseTexture = null;

            applyFilter('gamma', { gamma: 1.2 }, 1.0, false);
            layers.push({ name: 'gamma', params: { gamma: 1.2 }, strength: 1.0 });

            saveHistory();
            updateLayersList();
            updateHistogram();
        }

        function normalizeColors() {
            if (!currentTexture) return;

            // Exit preview mode if active
            isPreviewing = false;
            previewBaseTexture = null;

            applyFilter('saturation', { saturation: 1.0 }, 1.0, false);
            applyFilter('contrast', { contrast: 1.0 }, 1.0, false);

            layers.push({ name: 'normalize', params: {}, strength: 1.0 });

            saveHistory();
            updateLayersList();
            updateHistogram();
        }

        // Export
        function exportImage() {
            if (!canvas.width || !canvas.height) {
                alert('No image to export!');
                return;
            }

            const format = confirm('Export as PNG? (Cancel for JPEG)') ? 'png' : 'jpeg';
            const quality = format === 'jpeg' ? 0.95 : 1.0;

            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `filtered-image-${Date.now()}.${format}`;
                a.click();
                URL.revokeObjectURL(url);
            }, `image/${format}`, quality);
        }

        // Initialize on load
        window.addEventListener('load', initWebGL);
        window.addEventListener('resize', () => {
            if (originalImage) {
                fitToCanvas();
            }
        });
    </script>
</body>
</html>