<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Visualizer - Interactive Learning Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        header p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            padding: 20px;
        }

        .sidebar {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            height: fit-content;
        }

        .section {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }

        .control-group input[type="range"],
        .control-group input[type="number"],
        .control-group select {
            width: 100%;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .control-group input[type="range"]:focus,
        .control-group input[type="number"]:focus,
        .control-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .value-display {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
            margin-left: 8px;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 15px;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
        }

        button.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        button.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button.secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        button.secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(245, 87, 108, 0.4);
        }

        button.success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        button.success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }

        button.warning {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        button.warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(250, 112, 154, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .visualization-area {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .canvas-container {
            position: relative;
            margin-bottom: 20px;
        }

        canvas {
            display: block;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
            cursor: crosshair;
        }

        .charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .chart-wrapper {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .chart-wrapper h4 {
            color: #667eea;
            margin-bottom: 10px;
            text-align: center;
        }

        .status-bar {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .status-item {
            text-align: center;
        }

        .status-label {
            font-size: 0.85em;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .status-value {
            font-size: 1.3em;
            font-weight: bold;
        }

        .info-box {
            background: linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%);
            border-left: 4px solid #667eea;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .info-box h4 {
            color: #667eea;
            margin-bottom: 8px;
        }

        .dataset-preview {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .dataset-item {
            background: #f8f9fa;
            padding: 8px;
            border-radius: 6px;
            font-size: 0.85em;
            font-family: 'Courier New', monospace;
        }

        .dataset-item .input {
            color: #667eea;
            font-weight: bold;
        }

        .dataset-item .output {
            color: #764ba2;
            font-weight: bold;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.85em;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            line-height: 1.5;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: none;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .legend-color {
            width: 30px;
            height: 15px;
            border-radius: 3px;
            border: 1px solid #ddd;
        }

        .phase-indicator {
            text-align: center;
            padding: 10px;
            background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
            border-radius: 8px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .training-indicator {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .charts-container {
                grid-template-columns: 1fr;
            }
        }

        .architecture-display {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #667eea;
            margin-top: 10px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-group label {
            cursor: pointer;
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Neural Network Visualizer</h1>
            <p>Interactive Educational Tool for Understanding Deep Learning</p>
        </header>

        <div class="main-content">
            <div class="sidebar">
                <div class="section">
                    <h3>Network Architecture</h3>
                    <div class="control-group">
                        <label>Input Layer: <span class="value-display" id="inputDisplay">2</span></label>
                        <input type="range" id="inputNodes" min="2" max="4" value="2">
                    </div>
                    <div class="control-group">
                        <label>Hidden Layer: <span class="value-display" id="hiddenDisplay">4</span></label>
                        <input type="range" id="hiddenNodes" min="2" max="8" value="4">
                    </div>
                    <div class="control-group">
                        <label>Output Layer: <span class="value-display" id="outputDisplay">1</span></label>
                        <input type="range" id="outputNodes" min="1" max="2" value="1">
                    </div>
                    <div class="architecture-display" id="archDisplay">2-4-1</div>
                </div>

                <div class="section">
                    <h3>Training Parameters</h3>
                    <div class="control-group">
                        <label>Learning Rate: <span class="value-display" id="lrDisplay">0.1</span></label>
                        <input type="range" id="learningRate" min="0.01" max="1" step="0.01" value="0.1">
                    </div>
                    <div class="control-group">
                        <label>Epochs: <span class="value-display" id="epochDisplay">1000</span></label>
                        <input type="number" id="maxEpochs" min="100" max="10000" step="100" value="1000">
                    </div>
                    <div class="control-group">
                        <label>Animation Speed: <span class="value-display" id="speedDisplay">50</span></label>
                        <input type="range" id="animationSpeed" min="1" max="100" value="50">
                    </div>
                    <div class="control-group">
                        <label>Dataset:</label>
                        <select id="datasetSelect">
                            <option value="xor">XOR Problem</option>
                            <option value="and">AND Gate</option>
                            <option value="or">OR Gate</option>
                            <option value="circle">Circle Classification</option>
                        </select>
                    </div>
                </div>

                <div class="section">
                    <h3>Training Controls</h3>
                    <div class="button-group">
                        <button class="primary" id="trainBtn">Start Training</button>
                        <button class="secondary" id="pauseBtn" disabled>Pause</button>
                        <button class="success" id="stepBtn">Step Forward</button>
                        <button class="warning" id="resetBtn">Reset Network</button>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showAnimations" checked>
                        <label for="showAnimations">Show Animations</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showWeights" checked>
                        <label for="showWeights">Show Weights</label>
                    </div>
                </div>

                <div class="section">
                    <h3>Dataset Preview</h3>
                    <div id="datasetPreview" class="dataset-preview"></div>
                </div>

                <div class="info-box">
                    <h4>How it works:</h4>
                    <p><strong>Forward Pass:</strong> Data flows through layers, each neuron applies weights and activation functions.</p>
                    <p><strong>Backward Pass:</strong> Errors propagate backwards, updating weights via gradient descent.</p>
                    <p><strong>Colors:</strong> Blue = positive weights, Red = negative weights. Intensity shows magnitude.</p>
                </div>
            </div>

            <div class="visualization-area">
                <div class="status-bar">
                    <div class="status-item">
                        <div class="status-label">Epoch</div>
                        <div class="status-value" id="epochCount">0</div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Loss</div>
                        <div class="status-value" id="lossValue">-</div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Accuracy</div>
                        <div class="status-value" id="accuracyValue">-</div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Phase</div>
                        <div class="status-value" id="phaseValue">Idle</div>
                    </div>
                </div>

                <div class="canvas-container">
                    <canvas id="networkCanvas" width="1200" height="600"></canvas>
                    <div class="tooltip" id="tooltip"></div>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(to right, #2196F3, #0D47A1);"></div>
                        <span>Positive Weights</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(to right, #F44336, #B71C1C);"></div>
                        <span>Negative Weights</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: linear-gradient(to right, #4CAF50, #1B5E20);"></div>
                        <span>Active Neurons</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FFD700;"></div>
                        <span>Data Flow</span>
                    </div>
                </div>

                <div class="charts-container">
                    <div class="chart-wrapper">
                        <h4>Loss Over Time</h4>
                        <canvas id="lossChart" width="400" height="250"></canvas>
                    </div>
                    <div class="chart-wrapper">
                        <h4>Accuracy Over Time</h4>
                        <canvas id="accuracyChart" width="400" height="250"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Neural Network Implementation
        class NeuralNetwork {
            constructor(inputNodes, hiddenNodes, outputNodes, learningRate) {
                this.inputNodes = inputNodes;
                this.hiddenNodes = hiddenNodes;
                this.outputNodes = outputNodes;
                this.learningRate = learningRate;

                // Initialize weights with random values
                this.weightsInputHidden = this.randomMatrix(this.hiddenNodes, this.inputNodes);
                this.weightsHiddenOutput = this.randomMatrix(this.outputNodes, this.hiddenNodes);

                // Biases
                this.biasHidden = this.randomMatrix(this.hiddenNodes, 1);
                this.biasOutput = this.randomMatrix(this.outputNodes, 1);

                // Store activations for visualization
                this.inputActivations = [];
                this.hiddenActivations = [];
                this.outputActivations = [];
                this.hiddenInputs = [];
                this.outputInputs = [];
            }

            randomMatrix(rows, cols) {
                const matrix = [];
                for (let i = 0; i < rows; i++) {
                    matrix[i] = [];
                    for (let j = 0; j < cols; j++) {
                        matrix[i][j] = Math.random() * 2 - 1; // Range: -1 to 1
                    }
                }
                return matrix;
            }

            sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }

            sigmoidDerivative(x) {
                return x * (1 - x);
            }

            matrixMultiply(a, b) {
                const result = [];
                for (let i = 0; i < a.length; i++) {
                    result[i] = [];
                    for (let j = 0; j < b[0].length; j++) {
                        let sum = 0;
                        for (let k = 0; k < a[0].length; k++) {
                            sum += a[i][k] * b[k][j];
                        }
                        result[i][j] = sum;
                    }
                }
                return result;
            }

            matrixAdd(a, b) {
                const result = [];
                for (let i = 0; i < a.length; i++) {
                    result[i] = [];
                    for (let j = 0; j < a[0].length; j++) {
                        result[i][j] = a[i][j] + b[i][j];
                    }
                }
                return result;
            }

            matrixTranspose(matrix) {
                const result = [];
                for (let j = 0; j < matrix[0].length; j++) {
                    result[j] = [];
                    for (let i = 0; i < matrix.length; i++) {
                        result[j][i] = matrix[i][j];
                    }
                }
                return result;
            }

            applyFunction(matrix, func) {
                return matrix.map(row => row.map(val => func(val)));
            }

            feedforward(inputArray) {
                // Convert input to matrix
                const inputs = inputArray.map(x => [x]);
                this.inputActivations = inputs;

                // Calculate hidden layer
                let hidden = this.matrixMultiply(this.weightsInputHidden, inputs);
                hidden = this.matrixAdd(hidden, this.biasHidden);
                this.hiddenInputs = hidden;
                hidden = this.applyFunction(hidden, this.sigmoid.bind(this));
                this.hiddenActivations = hidden;

                // Calculate output layer
                let outputs = this.matrixMultiply(this.weightsHiddenOutput, hidden);
                outputs = this.matrixAdd(outputs, this.biasOutput);
                this.outputInputs = outputs;
                outputs = this.applyFunction(outputs, this.sigmoid.bind(this));
                this.outputActivations = outputs;

                return outputs.map(row => row[0]);
            }

            train(inputArray, targetArray) {
                // Feedforward
                const outputs = this.feedforward(inputArray);

                // Convert target to matrix
                const targets = targetArray.map(x => [x]);

                // Calculate output errors
                const outputErrors = [];
                for (let i = 0; i < this.outputActivations.length; i++) {
                    outputErrors[i] = [targets[i][0] - this.outputActivations[i][0]];
                }

                // Calculate output gradients
                const outputGradients = this.applyFunction(this.outputActivations, this.sigmoidDerivative.bind(this));
                for (let i = 0; i < outputGradients.length; i++) {
                    for (let j = 0; j < outputGradients[0].length; j++) {
                        outputGradients[i][j] *= outputErrors[i][j];
                        outputGradients[i][j] *= this.learningRate;
                    }
                }

                // Calculate hidden->output deltas
                const hiddenT = this.matrixTranspose(this.hiddenActivations);
                const weightHODeltas = this.matrixMultiply(outputGradients, hiddenT);

                // Update hidden->output weights and biases
                this.weightsHiddenOutput = this.matrixAdd(this.weightsHiddenOutput, weightHODeltas);
                this.biasOutput = this.matrixAdd(this.biasOutput, outputGradients);

                // Calculate hidden errors
                const weightsHOT = this.matrixTranspose(this.weightsHiddenOutput);
                const hiddenErrors = this.matrixMultiply(weightsHOT, outputErrors);

                // Calculate hidden gradients
                const hiddenGradients = this.applyFunction(this.hiddenActivations, this.sigmoidDerivative.bind(this));
                for (let i = 0; i < hiddenGradients.length; i++) {
                    for (let j = 0; j < hiddenGradients[0].length; j++) {
                        hiddenGradients[i][j] *= hiddenErrors[i][j];
                        hiddenGradients[i][j] *= this.learningRate;
                    }
                }

                // Calculate input->hidden deltas
                const inputsT = this.matrixTranspose(this.inputActivations);
                const weightIHDeltas = this.matrixMultiply(hiddenGradients, inputsT);

                // Update input->hidden weights and biases
                this.weightsInputHidden = this.matrixAdd(this.weightsInputHidden, weightIHDeltas);
                this.biasHidden = this.matrixAdd(this.biasHidden, hiddenGradients);

                return outputs;
            }
        }

        // Visualization Manager
        class NetworkVisualizer {
            constructor(canvas, network) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.network = network;
                this.layers = [];
                this.particles = [];
                this.animations = [];
                this.hoveredNeuron = null;
                this.setupEventListeners();
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    this.checkNeuronHover(x, y);
                });

                this.canvas.addEventListener('mouseleave', () => {
                    this.hoveredNeuron = null;
                    document.getElementById('tooltip').style.display = 'none';
                });
            }

            calculateLayout() {
                const width = this.canvas.width;
                const height = this.canvas.height;
                const layers = [
                    this.network.inputNodes,
                    this.network.hiddenNodes,
                    this.network.outputNodes
                ];

                this.layers = [];
                const layerSpacing = width / (layers.length + 1);

                layers.forEach((nodeCount, layerIndex) => {
                    const layer = [];
                    const nodeSpacing = height / (nodeCount + 1);
                    const x = layerSpacing * (layerIndex + 1);

                    for (let i = 0; i < nodeCount; i++) {
                        const y = nodeSpacing * (i + 1);
                        layer.push({ x, y, activation: 0, layerIndex, nodeIndex: i });
                    }
                    this.layers.push(layer);
                });
            }

            drawNetwork(showWeights, phase) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw connections
                if (showWeights) {
                    this.drawConnections();
                }

                // Draw neurons
                this.drawNeurons(phase);

                // Draw particles
                this.drawParticles();
            }

            drawConnections() {
                // Input to Hidden
                for (let i = 0; i < this.layers[0].length; i++) {
                    for (let j = 0; j < this.layers[1].length; j++) {
                        const weight = this.network.weightsInputHidden[j][i];
                        this.drawConnection(
                            this.layers[0][i],
                            this.layers[1][j],
                            weight
                        );
                    }
                }

                // Hidden to Output
                for (let i = 0; i < this.layers[1].length; i++) {
                    for (let j = 0; j < this.layers[2].length; j++) {
                        const weight = this.network.weightsHiddenOutput[j][i];
                        this.drawConnection(
                            this.layers[1][i],
                            this.layers[2][j],
                            weight
                        );
                    }
                }
            }

            drawConnection(from, to, weight) {
                const maxWeight = 2;
                const normalizedWeight = Math.max(-maxWeight, Math.min(maxWeight, weight)) / maxWeight;
                const alpha = Math.abs(normalizedWeight) * 0.7 + 0.1;
                const color = weight > 0 ? `rgba(33, 150, 243, ${alpha})` : `rgba(244, 67, 54, ${alpha})`;
                const lineWidth = Math.abs(normalizedWeight) * 3 + 0.5;

                this.ctx.beginPath();
                this.ctx.moveTo(from.x, from.y);
                this.ctx.lineTo(to.x, to.y);
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = lineWidth;
                this.ctx.stroke();
            }

            drawNeurons(phase) {
                this.layers.forEach((layer, layerIndex) => {
                    layer.forEach((neuron, nodeIndex) => {
                        let activation = 0;

                        // Get activation values
                        if (layerIndex === 0 && this.network.inputActivations.length > 0) {
                            activation = this.network.inputActivations[nodeIndex][0];
                        } else if (layerIndex === 1 && this.network.hiddenActivations.length > 0) {
                            activation = this.network.hiddenActivations[nodeIndex][0];
                        } else if (layerIndex === 2 && this.network.outputActivations.length > 0) {
                            activation = this.network.outputActivations[nodeIndex][0];
                        }

                        neuron.activation = activation;

                        // Draw neuron
                        const radius = 25;
                        const intensity = Math.abs(activation);
                        const hue = activation > 0.5 ? 120 : 0;
                        const gradient = this.ctx.createRadialGradient(
                            neuron.x, neuron.y, 0,
                            neuron.x, neuron.y, radius
                        );

                        gradient.addColorStop(0, `hsla(${hue}, 70%, ${50 + intensity * 30}%, 1)`);
                        gradient.addColorStop(1, `hsla(${hue}, 70%, ${30 + intensity * 20}%, 1)`);

                        this.ctx.beginPath();
                        this.ctx.arc(neuron.x, neuron.y, radius, 0, Math.PI * 2);
                        this.ctx.fillStyle = gradient;
                        this.ctx.fill();
                        this.ctx.strokeStyle = this.hoveredNeuron === neuron ? '#FFD700' : '#333';
                        this.ctx.lineWidth = this.hoveredNeuron === neuron ? 3 : 2;
                        this.ctx.stroke();

                        // Draw activation value
                        this.ctx.fillStyle = '#fff';
                        this.ctx.font = 'bold 12px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText(activation.toFixed(2), neuron.x, neuron.y);

                        // Draw label
                        this.ctx.fillStyle = '#333';
                        this.ctx.font = '11px Arial';
                        let label = '';
                        if (layerIndex === 0) label = `I${nodeIndex + 1}`;
                        else if (layerIndex === 1) label = `H${nodeIndex + 1}`;
                        else label = `O${nodeIndex + 1}`;
                        this.ctx.fillText(label, neuron.x, neuron.y + radius + 15);
                    });
                });
            }

            checkNeuronHover(mouseX, mouseY) {
                let found = false;
                for (const layer of this.layers) {
                    for (const neuron of layer) {
                        const dx = mouseX - neuron.x;
                        const dy = mouseY - neuron.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < 25) {
                            this.hoveredNeuron = neuron;
                            this.showTooltip(neuron, mouseX, mouseY);
                            found = true;
                            break;
                        }
                    }
                    if (found) break;
                }

                if (!found) {
                    this.hoveredNeuron = null;
                    document.getElementById('tooltip').style.display = 'none';
                }
            }

            showTooltip(neuron, mouseX, mouseY) {
                const tooltip = document.getElementById('tooltip');
                const layerNames = ['Input', 'Hidden', 'Output'];
                const layerName = layerNames[neuron.layerIndex];

                let info = `<strong>${layerName} Layer - Node ${neuron.nodeIndex + 1}</strong><br>`;
                info += `Activation: ${neuron.activation.toFixed(4)}<br>`;

                if (neuron.layerIndex === 1) {
                    info += `Bias: ${this.network.biasHidden[neuron.nodeIndex][0].toFixed(4)}`;
                } else if (neuron.layerIndex === 2) {
                    info += `Bias: ${this.network.biasOutput[neuron.nodeIndex][0].toFixed(4)}`;
                }

                tooltip.innerHTML = info;
                tooltip.style.display = 'block';
                tooltip.style.left = (mouseX + 15) + 'px';
                tooltip.style.top = (mouseY + 15) + 'px';
            }

            addParticle(fromLayer, toLayer) {
                const fromNeurons = this.layers[fromLayer];
                const toNeurons = this.layers[toLayer];

                fromNeurons.forEach(from => {
                    toNeurons.forEach(to => {
                        this.particles.push({
                            from: { x: from.x, y: from.y },
                            to: { x: to.x, y: to.y },
                            progress: 0,
                            speed: 0.02
                        });
                    });
                });
            }

            drawParticles() {
                this.particles = this.particles.filter(particle => {
                    particle.progress += particle.speed;

                    if (particle.progress >= 1) {
                        return false;
                    }

                    const x = particle.from.x + (particle.to.x - particle.from.x) * particle.progress;
                    const y = particle.from.y + (particle.to.y - particle.from.y) * particle.progress;

                    const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, 8);
                    gradient.addColorStop(0, 'rgba(255, 215, 0, 1)');
                    gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');

                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 8, 0, Math.PI * 2);
                    this.ctx.fillStyle = gradient;
                    this.ctx.fill();

                    return true;
                });
            }
        }

        // Chart Manager
        class ChartManager {
            constructor(lossCanvas, accuracyCanvas) {
                this.lossCanvas = lossCanvas;
                this.accuracyCanvas = accuracyCanvas;
                this.lossCtx = lossCanvas.getContext('2d');
                this.accuracyCtx = accuracyCanvas.getContext('2d');
                this.lossHistory = [];
                this.accuracyHistory = [];
                this.maxPoints = 100;
            }

            addData(loss, accuracy) {
                this.lossHistory.push(loss);
                this.accuracyHistory.push(accuracy);

                if (this.lossHistory.length > this.maxPoints) {
                    this.lossHistory.shift();
                    this.accuracyHistory.shift();
                }
            }

            drawCharts() {
                this.drawLossChart();
                this.drawAccuracyChart();
            }

            drawLossChart() {
                const ctx = this.lossCtx;
                const width = this.lossCanvas.width;
                const height = this.lossCanvas.height;
                const padding = 40;

                ctx.clearRect(0, 0, width, height);

                if (this.lossHistory.length === 0) return;

                // Background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);

                // Grid
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    const y = padding + (height - padding * 2) * i / 5;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(width - padding, y);
                    ctx.stroke();
                }

                // Find max loss
                const maxLoss = Math.max(...this.lossHistory, 1);

                // Draw line
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.beginPath();

                this.lossHistory.forEach((loss, index) => {
                    const x = padding + (width - padding * 2) * index / Math.max(this.lossHistory.length - 1, 1);
                    const y = height - padding - (height - padding * 2) * (loss / maxLoss);

                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                ctx.stroke();

                // Fill area under curve
                ctx.lineTo(width - padding, height - padding);
                ctx.lineTo(padding, height - padding);
                ctx.closePath();
                ctx.fillStyle = 'rgba(102, 126, 234, 0.1)';
                ctx.fill();

                // Labels
                ctx.fillStyle = '#333';
                ctx.font = '11px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(maxLoss.toFixed(2), padding - 5, padding);
                ctx.fillText('0', padding - 5, height - padding);
            }

            drawAccuracyChart() {
                const ctx = this.accuracyCtx;
                const width = this.accuracyCanvas.width;
                const height = this.accuracyCanvas.height;
                const padding = 40;

                ctx.clearRect(0, 0, width, height);

                if (this.accuracyHistory.length === 0) return;

                // Background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);

                // Grid
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    const y = padding + (height - padding * 2) * i / 5;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(width - padding, y);
                    ctx.stroke();
                }

                // Draw line
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.beginPath();

                this.accuracyHistory.forEach((accuracy, index) => {
                    const x = padding + (width - padding * 2) * index / Math.max(this.accuracyHistory.length - 1, 1);
                    const y = height - padding - (height - padding * 2) * accuracy;

                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                ctx.stroke();

                // Fill area under curve
                ctx.lineTo(width - padding, height - padding);
                ctx.lineTo(padding, height - padding);
                ctx.closePath();
                ctx.fillStyle = 'rgba(76, 175, 80, 0.1)';
                ctx.fill();

                // Labels
                ctx.fillStyle = '#333';
                ctx.font = '11px Arial';
                ctx.textAlign = 'right';
                ctx.fillText('100%', padding - 5, padding);
                ctx.fillText('0%', padding - 5, height - padding);
            }

            clear() {
                this.lossHistory = [];
                this.accuracyHistory = [];
                this.lossCtx.clearRect(0, 0, this.lossCanvas.width, this.lossCanvas.height);
                this.accuracyCtx.clearRect(0, 0, this.accuracyCanvas.width, this.accuracyCanvas.height);
            }
        }

        // Dataset Manager
        class DatasetManager {
            constructor() {
                this.datasets = {
                    xor: {
                        inputs: [[0, 0], [0, 1], [1, 0], [1, 1]],
                        outputs: [[0], [1], [1], [0]],
                        description: 'XOR Problem - Classic non-linearly separable dataset'
                    },
                    and: {
                        inputs: [[0, 0], [0, 1], [1, 0], [1, 1]],
                        outputs: [[0], [0], [0], [1]],
                        description: 'AND Gate - All inputs must be 1'
                    },
                    or: {
                        inputs: [[0, 0], [0, 1], [1, 0], [1, 1]],
                        outputs: [[0], [1], [1], [1]],
                        description: 'OR Gate - At least one input must be 1'
                    },
                    circle: {
                        inputs: [
                            [0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9],
                            [0.5, 0.5], [0.3, 0.7], [0.7, 0.3], [0.2, 0.8]
                        ],
                        outputs: [[0], [0], [0], [0], [1], [1], [1], [1]],
                        description: 'Circle Classification - Points near center vs edges'
                    }
                };
            }

            getDataset(name) {
                return this.datasets[name];
            }

            displayPreview(name) {
                const dataset = this.datasets[name];
                const preview = document.getElementById('datasetPreview');
                preview.innerHTML = '';

                dataset.inputs.forEach((input, index) => {
                    const item = document.createElement('div');
                    item.className = 'dataset-item';
                    item.innerHTML = `
                        <span class="input">[${input.join(', ')}]</span> â†’
                        <span class="output">[${dataset.outputs[index][0]}]</span>
                    `;
                    preview.appendChild(item);
                });
            }
        }

        // Main Application
        class NeuralNetworkApp {
            constructor() {
                this.network = null;
                this.visualizer = null;
                this.chartManager = null;
                this.datasetManager = new DatasetManager();
                this.isTraining = false;
                this.isPaused = false;
                this.currentEpoch = 0;
                this.maxEpochs = 1000;
                this.currentDataset = null;
                this.animationSpeed = 50;
                this.showAnimations = true;
                this.phase = 'idle';

                this.initializeUI();
                this.resetNetwork();
            }

            initializeUI() {
                // Canvas setup
                const canvas = document.getElementById('networkCanvas');
                const lossCanvas = document.getElementById('lossChart');
                const accuracyCanvas = document.getElementById('accuracyChart');

                this.chartManager = new ChartManager(lossCanvas, accuracyCanvas);

                // Control event listeners
                document.getElementById('trainBtn').addEventListener('click', () => this.startTraining());
                document.getElementById('pauseBtn').addEventListener('click', () => this.pauseTraining());
                document.getElementById('stepBtn').addEventListener('click', () => this.stepForward());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetNetwork());

                // Parameter listeners
                document.getElementById('inputNodes').addEventListener('input', (e) => {
                    document.getElementById('inputDisplay').textContent = e.target.value;
                    this.updateArchitectureDisplay();
                });

                document.getElementById('hiddenNodes').addEventListener('input', (e) => {
                    document.getElementById('hiddenDisplay').textContent = e.target.value;
                    this.updateArchitectureDisplay();
                });

                document.getElementById('outputNodes').addEventListener('input', (e) => {
                    document.getElementById('outputDisplay').textContent = e.target.value;
                    this.updateArchitectureDisplay();
                });

                document.getElementById('learningRate').addEventListener('input', (e) => {
                    document.getElementById('lrDisplay').textContent = parseFloat(e.target.value).toFixed(2);
                });

                document.getElementById('maxEpochs').addEventListener('input', (e) => {
                    document.getElementById('epochDisplay').textContent = e.target.value;
                });

                document.getElementById('animationSpeed').addEventListener('input', (e) => {
                    document.getElementById('speedDisplay').textContent = e.target.value;
                    this.animationSpeed = parseInt(e.target.value);
                });

                document.getElementById('datasetSelect').addEventListener('change', (e) => {
                    this.datasetManager.displayPreview(e.target.value);
                    this.resetNetwork();
                });

                document.getElementById('showAnimations').addEventListener('change', (e) => {
                    this.showAnimations = e.target.checked;
                });

                // Initial dataset preview
                this.datasetManager.displayPreview('xor');
            }

            updateArchitectureDisplay() {
                const input = document.getElementById('inputNodes').value;
                const hidden = document.getElementById('hiddenNodes').value;
                const output = document.getElementById('outputNodes').value;
                document.getElementById('archDisplay').textContent = `${input}-${hidden}-${output}`;
            }

            resetNetwork() {
                this.isTraining = false;
                this.isPaused = false;
                this.currentEpoch = 0;

                const inputNodes = parseInt(document.getElementById('inputNodes').value);
                const hiddenNodes = parseInt(document.getElementById('hiddenNodes').value);
                const outputNodes = parseInt(document.getElementById('outputNodes').value);
                const learningRate = parseFloat(document.getElementById('learningRate').value);

                this.network = new NeuralNetwork(inputNodes, hiddenNodes, outputNodes, learningRate);

                const canvas = document.getElementById('networkCanvas');
                this.visualizer = new NetworkVisualizer(canvas, this.network);
                this.visualizer.calculateLayout();

                this.chartManager.clear();

                this.updateStatus(0, 0, 0, 'Idle');
                document.getElementById('trainBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
                document.getElementById('stepBtn').disabled = false;

                this.visualizer.drawNetwork(document.getElementById('showWeights').checked, 'idle');
            }

            async startTraining() {
                if (this.isTraining) return;

                this.isTraining = true;
                this.isPaused = false;
                this.currentEpoch = 0;
                this.maxEpochs = parseInt(document.getElementById('maxEpochs').value);

                document.getElementById('trainBtn').disabled = true;
                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('stepBtn').disabled = true;

                const datasetName = document.getElementById('datasetSelect').value;
                this.currentDataset = this.datasetManager.getDataset(datasetName);

                await this.trainLoop();
            }

            pauseTraining() {
                this.isPaused = !this.isPaused;
                document.getElementById('pauseBtn').textContent = this.isPaused ? 'Resume' : 'Pause';

                if (!this.isPaused) {
                    this.trainLoop();
                }
            }

            async trainLoop() {
                while (this.isTraining && !this.isPaused && this.currentEpoch < this.maxEpochs) {
                    await this.trainEpoch();

                    // Delay based on animation speed
                    await new Promise(resolve => setTimeout(resolve, 101 - this.animationSpeed));
                }

                if (this.currentEpoch >= this.maxEpochs) {
                    this.finishTraining();
                }
            }

            async trainEpoch() {
                let totalLoss = 0;
                let correct = 0;

                for (let i = 0; i < this.currentDataset.inputs.length; i++) {
                    const input = this.currentDataset.inputs[i];
                    const target = this.currentDataset.outputs[i];

                    // Forward pass visualization
                    if (this.showAnimations) {
                        this.phase = 'forward';
                        this.visualizer.addParticle(0, 1);
                        this.visualizer.drawNetwork(document.getElementById('showWeights').checked, 'forward');
                        await new Promise(resolve => setTimeout(resolve, 50));

                        this.visualizer.addParticle(1, 2);
                        this.visualizer.drawNetwork(document.getElementById('showWeights').checked, 'forward');
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }

                    // Train
                    const output = this.network.train(input, target);

                    // Backward pass visualization
                    if (this.showAnimations) {
                        this.phase = 'backward';
                        this.visualizer.drawNetwork(document.getElementById('showWeights').checked, 'backward');
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }

                    // Calculate loss and accuracy
                    const loss = target.reduce((sum, t, j) => sum + Math.pow(t - output[j], 2), 0);
                    totalLoss += loss;

                    const predicted = output[0] > 0.5 ? 1 : 0;
                    if (predicted === target[0]) correct++;
                }

                this.currentEpoch++;
                const avgLoss = totalLoss / this.currentDataset.inputs.length;
                const accuracy = correct / this.currentDataset.inputs.length;

                this.chartManager.addData(avgLoss, accuracy);
                this.chartManager.drawCharts();
                this.updateStatus(this.currentEpoch, avgLoss, accuracy, 'Training');

                // Draw final state
                this.visualizer.drawNetwork(document.getElementById('showWeights').checked, 'training');
            }

            async stepForward() {
                if (!this.currentDataset) {
                    const datasetName = document.getElementById('datasetSelect').value;
                    this.currentDataset = this.datasetManager.getDataset(datasetName);
                }

                if (this.currentEpoch >= this.maxEpochs) {
                    this.resetNetwork();
                    return;
                }

                await this.trainEpoch();

                if (this.currentEpoch >= this.maxEpochs) {
                    this.finishTraining();
                }
            }

            finishTraining() {
                this.isTraining = false;
                this.isPaused = false;
                document.getElementById('trainBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
                document.getElementById('stepBtn').disabled = false;
                this.updateStatus(this.currentEpoch, null, null, 'Completed');
            }

            updateStatus(epoch, loss, accuracy, phase) {
                document.getElementById('epochCount').textContent = epoch;
                document.getElementById('lossValue').textContent = loss !== null ? loss.toFixed(4) : '-';
                document.getElementById('accuracyValue').textContent = accuracy !== null ? (accuracy * 100).toFixed(1) + '%' : '-';
                document.getElementById('phaseValue').textContent = phase;

                if (phase === 'Training') {
                    document.getElementById('phaseValue').classList.add('training-indicator');
                } else {
                    document.getElementById('phaseValue').classList.remove('training-indicator');
                }
            }
        }

        // Initialize the application
        window.addEventListener('DOMContentLoaded', () => {
            new NeuralNetworkApp();
        });
    </script>
</body>
</html>
