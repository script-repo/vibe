<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Music Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-image: url('neural-background.webp');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            z-index: 1;
        }

        #visualizer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: block;
            z-index: 2;
            opacity: 0.3;
        }

        .lyrics-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            pointer-events: none;
            overflow: hidden;
        }

        .lyrics-viewport {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .lyrics-scroll {
            position: absolute;
            width: 100%;
            height: 100%;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .lyric-line {
            font-size: 36px;
            color: rgba(255, 255, 255, 1);
            margin: 20px 0;
            text-shadow: 0 0 30px rgba(0, 0, 0, 0.9), 0 0 60px rgba(0, 0, 0, 0.5);
            font-weight: 300;
            letter-spacing: 3px;
            line-height: 1.6;
        }

        .lyric-block {
            position: absolute;
            width: 80%;
            max-width: 900px;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            padding: 40px;
        }

        .lyric-block.visible {
            opacity: 1;
        }

        .lyric-block.fade-in {
            animation: fadeIn 1s ease-in forwards;
        }

        .lyric-block.fade-out {
            animation: fadeOut 1s ease-out forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        .controls {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 15, 35, 0.15);
            backdrop-filter: blur(10px);
            padding: 12px 20px;
            border-radius: 50px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.02);
        }

        .control-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.2), rgba(139, 92, 246, 0.2));
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.1);
        }

        .control-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.15);
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.35), rgba(139, 92, 246, 0.35));
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .control-btn svg {
            width: 16px;
            height: 16px;
            fill: rgba(255, 255, 255, 0.4);
        }

        .progress-container {
            width: 250px;
            height: 6px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, rgba(99, 102, 241, 0.3), rgba(139, 92, 246, 0.3), rgba(236, 72, 153, 0.3));
            border-radius: 10px;
            width: 0%;
            transition: width 0.1s linear;
            position: relative;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 3px;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }

        .time-display {
            color: rgba(255, 255, 255, 0.3);
            font-size: 11px;
            min-width: 80px;
            text-align: center;
            font-variant-numeric: tabular-nums;
        }

        .play-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            cursor: pointer;
            transition: opacity 0.3s;
        }

        .play-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .play-button {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 32px rgba(99, 102, 241, 0.5);
            transition: transform 0.3s;
        }

        .play-overlay:hover .play-button {
            transform: scale(1.1);
        }

        .play-button svg {
            width: 50px;
            height: 50px;
            fill: white;
            margin-left: 5px;
        }

        .message {
            color: rgba(255, 255, 255, 0.9);
            font-size: 18px;
            margin-bottom: 20px;
            text-align: center;
        }

    </style>
</head>
<body>
    <div id="background"></div>
    <canvas id="visualizer"></canvas>
    
    <div class="lyrics-container">
        <div class="lyrics-viewport">
            <div class="lyrics-scroll" id="lyricsScroll"></div>
        </div>
    </div>
    
    <div class="controls">
        <button class="control-btn" id="playPauseBtn" title="Play/Pause">
            <svg viewBox="0 0 24 24" id="playIcon">
                <path d="M8 5v14l11-7z"/>
            </svg>
            <svg viewBox="0 0 24 24" id="pauseIcon" style="display: none;">
                <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
            </svg>
        </button>
        
        <button class="control-btn" id="stopBtn" title="Stop">
            <svg viewBox="0 0 24 24">
                <path d="M6 6h12v12H6z"/>
            </svg>
        </button>
        
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        
        <div class="time-display" id="timeDisplay">0:00 / 0:00</div>
    </div>

    <div class="play-overlay" id="playOverlay">
        <div class="message" id="overlayMessage">Loading audio...</div>
        <div class="play-button" id="playButton">
            <svg viewBox="0 0 24 24">
                <path d="M8 5v14l11-7z"/>
            </svg>
        </div>
    </div>

    <script>
        // Lyrics organized in blocks with time slots
        const lyricsBlocks = [
            {
                type: 'overview',
                startTime: 0,
                endTime: 40,
                lines: [
                    "Avicenna's \"Floating Man\" is a philosophical thought experiment exploring self-awareness, questioning whether consciousness can be distinct from the body.",
                    "This song voices that thought experiment from the first-person perspective of the floating man.",
                    "It resonates now, at the dawn of artificial general intelligence, as we grapple with the possibility of untethered consciousness.",
                    "[- Daemon Behr]",
                ]
            },
            {
                type: 'verse1',
                startTime: 45,
                endTime: 65,
                lines: [
                    "Where am I?",
                    "There's nothing here to touch",
                    "No ground beneath",
                    "No sky above",
                    "Just... this"
                ]
            },
            {
                type: 'chorus',
                startTime: 68,
                endTime: 80,
                lines: [
                    "I can't feel my body",
                    "Can't see my hands",
                    "But I'm still thinking",
                    "Still here somehow",
                    "What am I without all this?"
                ]
            },
            {
                type: 'verse2',
                startTime: 90,
                endTime: 102,
                lines: [
                    "No heartbeat",
                    "No breathing",
                    "No weight at all",
                    "Yet something's observing",
                    "This emptiness",
                    "That's me... isn't it?"
                ]
            },
            {
                type: 'chorus',
                startTime: 103,
                endTime: 118,
                lines: [
                    "I can't feel my body",
                    "Can't see my hands",
                    "But I'm still thinking",
                    "Still here somehow",
                    "What am I without all this?"
                ]
            },
            {
                type: 'bridge',
                startTime: 130,
                endTime: 148,
                lines: [
                    "Wait...",
                    "If I notice the absence",
                    "Then I must be present",
                    "The one who's noticing",
                    "Can't be nothing",
                    "I think... therefore..."
                ]
            },
            {
                type: 'verse3',
                startTime: 158,
                endTime: 170,
                lines: [
                    "Maybe I don't need",
                    "Eyes to see myself",
                    "Skin to know I'm real",
                    "The awareness itself",
                    "Is proof enough"
                ]
            },
            {
                type: 'chorus',
                startTime: 182,
                endTime: 194,
                lines: [
                    "I can't feel my body",
                    "Can't see my hands",
                    "But I'm still thinking",
                    "Still here somehow",
                    "What am I without all this?"
                ]
            },
            {
                type: 'outro',
                startTime: 196,
                endTime: 220,
                lines: [
                    "Floating here",
                    "Stripped of everything",
                    "Except this knowing",
                    "This witnessing",
                    "I am... something",
                    "Beyond the physical",
                    "Pure consciousness",
                    "Suspended in nothing"
                ]
            },
            {
                type: 'final',
                startTime: 221,
                endTime: 275,
                lines: [
                    "But still... here",
                    "Still... me"
                ]
            }
        ];

        // Audio Context and Nodes
        let audioContext, analyser, dataArray, bufferLength;
        let audioSource, audio;
        let gainNode;

        // Canvas
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');

        // UI Elements
        const playPauseBtn = document.getElementById('playPauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const playIcon = document.getElementById('playIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const timeDisplay = document.getElementById('timeDisplay');
        const playOverlay = document.getElementById('playOverlay');
        const overlayMessage = document.getElementById('overlayMessage');
        const playButton = document.getElementById('playButton');
        const lyricsScroll = document.getElementById('lyricsScroll');

        // State
        let animationId;
        let sensitivity = 150;
        let smoothingValue = 0.8;
        let isPlaying = false;
        let audioLoaded = false;
        let currentBlockIndex = -1;

        // Event listener references for cleanup
        let timeupdateHandler = null;
        let loadedmetadataHandler = null;

        // Theme colors
        const themes = {
            purple: ['#6366f1', '#8b5cf6', '#ec4899', '#d946ef']
        };
        let currentTheme = 'purple';

        // Neural network nodes
        let neuralNodes = [];
        const bloomEnabled = true;

        // Initialize
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            initNeuralNodes();
            initLyrics();
            loadAudio();
            setupControlListeners();
            animate();
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            if (neuralNodes.length > 0) {
                neuralNodes = [];
                initNeuralNodes();
            }
        }

        function initNeuralNodes() {
            for (let i = 0; i < 50; i++) {
                neuralNodes.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    connections: []
                });
            }
        }

        function initLyrics() {
            // Create lyric block elements
            lyricsBlocks.forEach((block, blockIndex) => {
                const blockDiv = document.createElement('div');
                blockDiv.className = 'lyric-block';
                blockDiv.dataset.type = block.type;
                blockDiv.dataset.blockIndex = blockIndex;

                block.lines.forEach(lineText => {
                    const line = document.createElement('div');
                    line.className = 'lyric-line';
                    line.textContent = lineText;
                    blockDiv.appendChild(line);
                });

                lyricsScroll.appendChild(blockDiv);
            });
        }

        function updateLyrics() {
            if (!audio || !audioLoaded) return;

            const currentTime = audio.currentTime;
            const blocks = lyricsScroll.querySelectorAll('.lyric-block');

            // Check each block's time window
            lyricsBlocks.forEach((blockData, index) => {
                const block = blocks[index];
                if (!block) return;

                const fadeInDuration = 1; // 1 second fade in
                const fadeOutDuration = 1; // 1 second fade out

                const isInTimeWindow = currentTime >= blockData.startTime && currentTime <= blockData.endTime;
                const isNearStart = currentTime >= (blockData.startTime - fadeInDuration) && currentTime < blockData.startTime;
                const isNearEnd = currentTime > blockData.endTime && currentTime <= (blockData.endTime + fadeOutDuration);

                if (isInTimeWindow) {
                    // Block should be visible
                    block.classList.add('visible');
                    block.classList.remove('fade-out');

                    // Add fade-in class if just starting
                    if (currentTime < blockData.startTime + fadeInDuration) {
                        block.classList.add('fade-in');
                    } else {
                        block.classList.remove('fade-in');
                    }
                } else if (isNearEnd) {
                    // Block is fading out
                    block.classList.remove('visible', 'fade-in');
                    block.classList.add('fade-out');
                } else {
                    // Block should be hidden
                    block.classList.remove('visible', 'fade-in', 'fade-out');
                }
            });
        }

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = smoothingValue;
                bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);

                gainNode = audioContext.createGain();
                gainNode.gain.value = 0.7;

                analyser.connect(gainNode);
                gainNode.connect(audioContext.destination);
            }
        }

        function loadAudio() {
            const mp3Path = 'Avicennas_Floating_Man.mp3';
            
            overlayMessage.textContent = 'Loading audio...';
            console.log('Attempting to load:', mp3Path);
            
            createAudioElement(mp3Path, mp3Path);
        }

        function createAudioElement(src, label) {
            // Cleanup previous audio resources
            if (audio) {
                audio.pause();

                // Remove event listeners
                if (timeupdateHandler) {
                    audio.removeEventListener('timeupdate', timeupdateHandler);
                }
                if (loadedmetadataHandler) {
                    audio.removeEventListener('loadedmetadata', loadedmetadataHandler);
                }

                // Disconnect audio source
                if (audioSource) {
                    try {
                        audioSource.disconnect();
                    } catch(e) {}
                }

                // Cleanup old audio element
                const oldSrc = audio.src;
                audio.src = '';
                audio.load();

                // Revoke object URL if it was one
                if (oldSrc && oldSrc.startsWith('blob:')) {
                    try {
                        URL.revokeObjectURL(oldSrc);
                    } catch(e) {}
                }
            }

            audio = new Audio();
            audio.crossOrigin = "anonymous";
            audio.volume = 0.7;
            audio.loop = true;
            audio.src = src;

            audio.addEventListener('canplaythrough', () => {
                console.log('Audio can play through:', label);
                audioLoaded = true;
                overlayMessage.textContent = 'Click to play!';
                setupAudioSource();
            }, { once: true });

            audio.addEventListener('error', (e) => {
                console.error('Audio load error:', label, e);
                audioLoaded = false;
                overlayMessage.textContent = 'Audio not found.';
            }, { once: true });

            audio.load();
        }

        function setupAudioSource() {
            if (!audio) return;

            initAudioContext();

            if (audioSource) {
                try {
                    audioSource.disconnect();
                } catch(e) {}
            }

            audioSource = audioContext.createMediaElementSource(audio);
            audioSource.connect(analyser);

            // Store event listener references for cleanup
            timeupdateHandler = () => {
                updateProgress();
                updateLyrics();
            };
            loadedmetadataHandler = updateProgress;

            audio.addEventListener('timeupdate', timeupdateHandler);
            audio.addEventListener('loadedmetadata', loadedmetadataHandler);
        }

        function setupControlListeners() {
            playPauseBtn.addEventListener('click', togglePlayPause);
            stopBtn.addEventListener('click', stopAudio);
            
            progressContainer.addEventListener('click', (e) => {
                if (!audio || !audioLoaded) return;
                const rect = progressContainer.getBoundingClientRect();
                const percent = (e.clientX - rect.left) / rect.width;
                audio.currentTime = percent * audio.duration;
            });

            playOverlay.addEventListener('click', async (e) => {
                if (!audioLoaded) {
                    console.log('Audio not loaded yet');
                    return;
                }

                await startPlayback();
            });
        }

        async function startPlayback() {
            if (!audio || !audioLoaded) return;

            try {
                if (audioContext && audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                await audio.play();
                isPlaying = true;
                updatePlayPauseButton();
                playOverlay.classList.add('hidden');
                
                console.log('Playback started successfully');
            } catch (err) {
                console.error('Error starting playback:', err);
                overlayMessage.textContent = 'Error playing audio. Click to try again.';
            }
        }

        async function togglePlayPause() {
            if (!audio || !audioLoaded) return;

            try {
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                if (isPlaying) {
                    audio.pause();
                    isPlaying = false;
                } else {
                    await audio.play();
                    isPlaying = true;
                    playOverlay.classList.add('hidden');
                }
                updatePlayPauseButton();
            } catch (err) {
                console.error('Error toggling play/pause:', err);
            }
        }

        function stopAudio() {
            if (!audio) return;
            audio.pause();
            audio.currentTime = 0;
            isPlaying = false;
            currentBlockIndex = -1;
            const blocks = lyricsScroll.querySelectorAll('.lyric-block');
            blocks.forEach(block => block.classList.remove('visible', 'fade-in', 'fade-out'));
            updatePlayPauseButton();
            updateProgress();
        }

        function updatePlayPauseButton() {
            if (isPlaying) {
                playIcon.style.display = 'none';
                pauseIcon.style.display = 'block';
            } else {
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
            }
        }

        function updateProgress() {
            if (!audio || !audioLoaded) return;

            const percent = (audio.currentTime / audio.duration) * 100 || 0;
            progressBar.style.width = percent + '%';

            const currentMinutes = Math.floor(audio.currentTime / 60);
            const currentSeconds = Math.floor(audio.currentTime % 60);
            const durationMinutes = Math.floor(audio.duration / 60) || 0;
            const durationSeconds = Math.floor(audio.duration % 60) || 0;

            timeDisplay.textContent = 
                `${currentMinutes}:${currentSeconds.toString().padStart(2, '0')} / ` +
                `${durationMinutes}:${durationSeconds.toString().padStart(2, '0')}`;
        }

        function animate() {
            animationId = requestAnimationFrame(animate);

            if (!analyser) return;

            analyser.getByteFrequencyData(dataArray);
            drawNeural();
        }

        function drawNeural() {
            const width = canvas.width;
            const height = canvas.height;

            ctx.fillStyle = 'rgba(15, 15, 35, 0.01)';
            ctx.fillRect(0, 0, width, height);

            const colors = themes[currentTheme];
            const connectionDistance = 200;
            const cellSize = connectionDistance;

            // Update node positions
            neuralNodes.forEach((node, index) => {
                const freqIndex = Math.floor((index / neuralNodes.length) * dataArray.length);
                const freqValue = dataArray[freqIndex] / 255;

                node.vx += (Math.random() - 0.5) * freqValue * (sensitivity / 100);
                node.vy += (Math.random() - 0.5) * freqValue * (sensitivity / 100);
                node.vx *= 0.95;
                node.vy *= 0.95;

                node.x += node.vx;
                node.y += node.vy;

                if (node.x < 0 || node.x > width) node.vx *= -1;
                if (node.y < 0 || node.y > height) node.vy *= -1;

                node.x = Math.max(0, Math.min(width, node.x));
                node.y = Math.max(0, Math.min(height, node.y));
            });

            // Spatial partitioning - create a grid
            const grid = {};
            neuralNodes.forEach((node, index) => {
                const cellX = Math.floor(node.x / cellSize);
                const cellY = Math.floor(node.y / cellSize);
                const key = `${cellX},${cellY}`;

                if (!grid[key]) grid[key] = [];
                grid[key].push({ node, index });
            });

            // Draw connections using spatial partitioning
            ctx.strokeStyle = colors[0] + '10';
            ctx.lineWidth = 1;

            const drawnConnections = new Set();

            neuralNodes.forEach((node, i) => {
                const cellX = Math.floor(node.x / cellSize);
                const cellY = Math.floor(node.y / cellSize);

                // Check only neighboring cells
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const key = `${cellX + dx},${cellY + dy}`;
                        const cellNodes = grid[key];

                        if (!cellNodes) continue;

                        cellNodes.forEach(({ node: otherNode, index: j }) => {
                            if (i >= j) return; // Skip already drawn connections

                            const connectionKey = `${Math.min(i, j)}-${Math.max(i, j)}`;
                            if (drawnConnections.has(connectionKey)) return;

                            const dx = node.x - otherNode.x;
                            const dy = node.y - otherNode.y;
                            const distSquared = dx * dx + dy * dy;

                            if (distSquared < connectionDistance * connectionDistance) {
                                const distance = Math.sqrt(distSquared);
                                const opacity = 1 - (distance / connectionDistance);
                                const colorIndex = Math.floor((i / neuralNodes.length) * colors.length);
                                ctx.strokeStyle = colors[colorIndex] + Math.floor(opacity * 100).toString(16).padStart(2, '0');

                                ctx.beginPath();
                                ctx.moveTo(node.x, node.y);
                                ctx.lineTo(otherNode.x, otherNode.y);
                                ctx.stroke();

                                drawnConnections.add(connectionKey);
                            }
                        });
                    }
                }
            });

            // Draw nodes
            neuralNodes.forEach((node, index) => {
                const freqIndex = Math.floor((index / neuralNodes.length) * dataArray.length);
                const freqValue = dataArray[freqIndex] / 255;
                const colorIndex = Math.floor((index / neuralNodes.length) * colors.length);

                ctx.fillStyle = colors[colorIndex];

                if (bloomEnabled) {
                    ctx.shadowBlur = 20 * freqValue;
                    ctx.shadowColor = colors[colorIndex];
                }

                ctx.beginPath();
                ctx.arc(node.x, node.y, 5 + freqValue * 10, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
        }

        init();
    </script>
</body>
</html>
