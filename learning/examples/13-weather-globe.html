<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Globe 3D - Immersive Weather Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* Glassmorphism UI */
        .glass-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 20px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        /* Header */
        #header {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            text-align: center;
        }

        #header h1 {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(100, 200, 255, 0.8);
            letter-spacing: 2px;
        }

        /* Search Panel */
        #search-panel {
            position: fixed;
            top: 120px;
            left: 20px;
            z-index: 100;
            width: 300px;
        }

        #search-input {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            color: #fff;
            font-size: 16px;
            outline: none;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        #search-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        #search-results {
            margin-top: 10px;
            max-height: 300px;
            overflow-y: auto;
            border-radius: 15px;
        }

        .search-result-item {
            padding: 12px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
            margin-bottom: 5px;
            border-radius: 10px;
            transition: all 0.3s;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .search-result-item:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateX(5px);
        }

        /* Weather Info Panel */
        #weather-info {
            position: fixed;
            top: 120px;
            right: 20px;
            z-index: 100;
            width: 350px;
            max-height: calc(100vh - 140px);
            overflow-y: auto;
            display: none;
        }

        #weather-info.active {
            display: block;
        }

        .weather-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .weather-header h2 {
            font-size: 2em;
            margin-bottom: 5px;
        }

        .weather-header .country {
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.2em;
        }

        .current-weather {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
        }

        .temperature {
            font-size: 4em;
            font-weight: bold;
            margin: 10px 0;
        }

        .weather-icon {
            font-size: 4em;
            margin: 10px 0;
        }

        .weather-description {
            font-size: 1.3em;
            text-transform: capitalize;
            margin-bottom: 10px;
        }

        .weather-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }

        .weather-detail {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 10px;
            text-align: center;
        }

        .weather-detail-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .weather-detail-value {
            font-size: 1.3em;
            font-weight: bold;
        }

        /* Forecast Cards */
        .forecast-section {
            margin-top: 20px;
        }

        .forecast-section h3 {
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .forecast-cards {
            display: grid;
            gap: 10px;
        }

        .forecast-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .forecast-day {
            font-weight: bold;
        }

        .forecast-temps {
            display: flex;
            gap: 10px;
        }

        .forecast-high {
            color: #ff6b6b;
        }

        .forecast-low {
            color: #4dabf7;
        }

        /* Controls Panel */
        #controls-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            max-width: 300px;
        }

        .control-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .control-btn.active {
            background: rgba(100, 200, 255, 0.4);
            border-color: rgba(100, 200, 255, 0.6);
        }

        /* Legend */
        #legend {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            width: 250px;
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 30px;
            height: 20px;
            border-radius: 5px;
            margin-right: 10px;
        }

        /* Mini Map */
        #mini-map {
            position: fixed;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            width: 150px;
            height: 75px;
            display: none;
        }

        #mini-map canvas {
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }

        /* Loading */
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            text-align: center;
            font-size: 1.5em;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #fff;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        /* Tooltip for city markers */
        .city-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        /* Mobile responsive styles */
        @media (max-width: 768px) {
            #header h1 {
                font-size: 1.5em;
                letter-spacing: 1px;
            }

            #search-panel {
                top: 80px;
                left: 10px;
                right: 10px;
                width: auto;
            }

            #search-input {
                padding: 12px;
                font-size: 14px;
            }

            #info-panel {
                position: fixed;
                bottom: 10px;
                left: 10px;
                right: 10px;
                width: auto;
                max-height: 40vh;
                overflow-y: auto;
            }

            .glass-panel {
                padding: 15px;
                border-radius: 15px;
            }

            #controls {
                position: fixed;
                bottom: 10px;
                right: 10px;
                width: auto;
            }

            .control-btn {
                padding: 8px 12px;
                font-size: 12px;
            }

            #weather-details {
                font-size: 13px;
            }

            .weather-stat {
                padding: 8px;
            }
        }

        @media (max-width: 480px) {
            #header {
                top: 10px;
            }

            #header h1 {
                font-size: 1.2em;
            }

            #search-panel {
                top: 60px;
            }

            #search-input {
                padding: 10px;
                font-size: 13px;
            }

            .glass-panel {
                padding: 12px;
            }

            #info-panel {
                max-height: 35vh;
                font-size: 12px;
            }

            .control-btn {
                padding: 6px 10px;
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="loading">
        <div class="spinner"></div>
        <div>Initializing Weather Globe...</div>
    </div>

    <div id="header" class="glass-panel">
        <h1>üåç Weather Globe 3D</h1>
    </div>

    <div id="search-panel">
        <input type="text" id="search-input" placeholder="üîç Search for a city...">
        <div id="search-results"></div>
    </div>

    <div id="weather-info" class="glass-panel">
        <!-- Weather info will be dynamically populated -->
    </div>

    <div id="controls-panel">
        <button class="control-btn active" id="auto-rotate-btn">üîÑ Auto Rotate</button>
        <button class="control-btn active" id="clouds-btn">‚òÅÔ∏è Clouds</button>
        <button class="control-btn active" id="day-night-btn">üåì Day/Night</button>
        <button class="control-btn" id="temperature-btn">üå°Ô∏è Temperature</button>
        <button class="control-btn" id="reset-btn">üè† Reset View</button>
    </div>

    <div id="legend" class="glass-panel">
        <div class="legend-title">Temperature Scale</div>
        <div class="legend-item">
            <div class="legend-color" style="background: #1e3a8a;"></div>
            <span>&lt; -10¬∞C (Cold)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #3b82f6;"></div>
            <span>-10¬∞C to 10¬∞C</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #22c55e;"></div>
            <span>10¬∞C to 20¬∞C</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #eab308;"></div>
            <span>20¬∞C to 30¬∞C</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ef4444;"></div>
            <span>&gt; 30¬∞C (Hot)</span>
        </div>
    </div>

    <div class="city-tooltip" id="tooltip"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ====================================
        // GLOBAL VARIABLES
        // ====================================
        let scene, camera, renderer, globe, clouds, atmosphere, stars;
        let cities = [];
        let cityMarkers = [];
        let selectedCity = null;
        let autoRotate = true;
        let showClouds = true;
        let showDayNight = true;
        let showTemperature = false;
        let raycaster, mouse;
        let controls = {
            isDragging: false,
            previousMousePosition: { x: 0, y: 0 },
            rotationSpeed: { x: 0, y: 0 }
        };

        // ====================================
        // WEATHER ICONS
        // ====================================
        const weatherIcons = {
            clear: '‚òÄÔ∏è',
            clouds: '‚òÅÔ∏è',
            rain: 'üåßÔ∏è',
            snow: '‚ùÑÔ∏è',
            thunderstorm: '‚õàÔ∏è',
            drizzle: 'üå¶Ô∏è',
            mist: 'üå´Ô∏è',
            fog: 'üå´Ô∏è'
        };

        // ====================================
        // CITY DATA
        // ====================================
        const cityData = [
            { name: 'Tokyo', country: 'Japan', lat: 35.6762, lon: 139.6503 },
            { name: 'New York', country: 'USA', lat: 40.7128, lon: -74.0060 },
            { name: 'London', country: 'UK', lat: 51.5074, lon: -0.1278 },
            { name: 'Paris', country: 'France', lat: 48.8566, lon: 2.3522 },
            { name: 'Sydney', country: 'Australia', lat: -33.8688, lon: 151.2093 },
            { name: 'Dubai', country: 'UAE', lat: 25.2048, lon: 55.2708 },
            { name: 'Singapore', country: 'Singapore', lat: 1.3521, lon: 103.8198 },
            { name: 'Hong Kong', country: 'China', lat: 22.3193, lon: 114.1694 },
            { name: 'Los Angeles', country: 'USA', lat: 34.0522, lon: -118.2437 },
            { name: 'Chicago', country: 'USA', lat: 41.8781, lon: -87.6298 },
            { name: 'Toronto', country: 'Canada', lat: 43.6532, lon: -79.3832 },
            { name: 'S√£o Paulo', country: 'Brazil', lat: -23.5505, lon: -46.6333 },
            { name: 'Mexico City', country: 'Mexico', lat: 19.4326, lon: -99.1332 },
            { name: 'Moscow', country: 'Russia', lat: 55.7558, lon: 37.6173 },
            { name: 'Istanbul', country: 'Turkey', lat: 41.0082, lon: 28.9784 },
            { name: 'Cairo', country: 'Egypt', lat: 30.0444, lon: 31.2357 },
            { name: 'Mumbai', country: 'India', lat: 19.0760, lon: 72.8777 },
            { name: 'Delhi', country: 'India', lat: 28.7041, lon: 77.1025 },
            { name: 'Bangkok', country: 'Thailand', lat: 13.7563, lon: 100.5018 },
            { name: 'Seoul', country: 'South Korea', lat: 37.5665, lon: 126.9780 },
            { name: 'Beijing', country: 'China', lat: 39.9042, lon: 116.4074 },
            { name: 'Shanghai', country: 'China', lat: 31.2304, lon: 121.4737 },
            { name: 'Berlin', country: 'Germany', lat: 52.5200, lon: 13.4050 },
            { name: 'Madrid', country: 'Spain', lat: 40.4168, lon: -3.7038 },
            { name: 'Rome', country: 'Italy', lat: 41.9028, lon: 12.4964 },
            { name: 'Amsterdam', country: 'Netherlands', lat: 52.3676, lon: 4.9041 },
            { name: 'Vienna', country: 'Austria', lat: 48.2082, lon: 16.3738 },
            { name: 'Buenos Aires', country: 'Argentina', lat: -34.6037, lon: -58.3816 },
            { name: 'Rio de Janeiro', country: 'Brazil', lat: -22.9068, lon: -43.1729 },
            { name: 'Cape Town', country: 'South Africa', lat: -33.9249, lon: 18.4241 },
            { name: 'Lagos', country: 'Nigeria', lat: 6.5244, lon: 3.3792 },
            { name: 'Nairobi', country: 'Kenya', lat: -1.2921, lon: 36.8219 },
            { name: 'Stockholm', country: 'Sweden', lat: 59.3293, lon: 18.0686 },
            { name: 'Copenhagen', country: 'Denmark', lat: 55.6761, lon: 12.5683 },
            { name: 'Oslo', country: 'Norway', lat: 59.9139, lon: 10.7522 },
            { name: 'Helsinki', country: 'Finland', lat: 60.1699, lon: 24.9384 },
            { name: 'Warsaw', country: 'Poland', lat: 52.2297, lon: 21.0122 },
            { name: 'Prague', country: 'Czech Republic', lat: 50.0755, lon: 14.4378 },
            { name: 'Athens', country: 'Greece', lat: 37.9838, lon: 23.7275 },
            { name: 'Lisbon', country: 'Portugal', lat: 38.7223, lon: -9.1393 },
            { name: 'Vancouver', country: 'Canada', lat: 49.2827, lon: -123.1207 },
            { name: 'Montreal', country: 'Canada', lat: 45.5017, lon: -73.5673 },
            { name: 'San Francisco', country: 'USA', lat: 37.7749, lon: -122.4194 },
            { name: 'Seattle', country: 'USA', lat: 47.6062, lon: -122.3321 },
            { name: 'Miami', country: 'USA', lat: 25.7617, lon: -80.1918 },
            { name: 'Las Vegas', country: 'USA', lat: 36.1699, lon: -115.1398 },
            { name: 'Boston', country: 'USA', lat: 42.3601, lon: -71.0589 },
            { name: 'Washington DC', country: 'USA', lat: 38.9072, lon: -77.0369 }
        ];

        // ====================================
        // UTILITY FUNCTIONS
        // ====================================
        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);

            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const z = (radius * Math.sin(phi) * Math.sin(theta));
            const y = (radius * Math.cos(phi));

            return new THREE.Vector3(x, y, z);
        }

        function getTemperatureColor(temp) {
            if (temp < -10) return new THREE.Color(0x1e3a8a);
            if (temp < 10) return new THREE.Color(0x3b82f6);
            if (temp < 20) return new THREE.Color(0x22c55e);
            if (temp < 30) return new THREE.Color(0xeab308);
            return new THREE.Color(0xef4444);
        }

        function generateWeatherData(city) {
            // Current date for seasonal variations
            const now = new Date();
            const monthIndex = now.getMonth(); // 0-11
            const isNorthernSummer = monthIndex >= 5 && monthIndex <= 8; // Jun-Sep
            const isNorthernWinter = monthIndex >= 11 || monthIndex <= 2; // Dec-Mar

            // Latitude-based climate zones
            const lat = city.lat;
            const absLat = Math.abs(lat);
            const isNorthern = lat > 0;

            // Determine climate zone and base temperature
            let baseTemp, tempVariation, weatherProbs;

            // Arctic/Antarctic (>66¬∞)
            if (absLat > 66) {
                const isSummer = (isNorthern && isNorthernSummer) || (!isNorthern && isNorthernWinter);
                baseTemp = isSummer ? 5 : -25;
                tempVariation = 10;
                weatherProbs = { clear: 0.3, clouds: 0.3, snow: 0.3, mist: 0.1 };
            }
            // Cold temperate (45-66¬∞)
            else if (absLat > 45) {
                const isSummer = (isNorthern && isNorthernSummer) || (!isNorthern && isNorthernWinter);
                baseTemp = isSummer ? 22 : 0;
                tempVariation = 8;
                weatherProbs = isSummer
                    ? { clear: 0.35, clouds: 0.35, rain: 0.2, drizzle: 0.1 }
                    : { clear: 0.25, clouds: 0.3, snow: 0.25, rain: 0.15, mist: 0.05 };
            }
            // Temperate (30-45¬∞)
            else if (absLat > 30) {
                const isSummer = (isNorthern && isNorthernSummer) || (!isNorthern && isNorthernWinter);
                baseTemp = isSummer ? 28 : 8;
                tempVariation = 6;
                weatherProbs = isSummer
                    ? { clear: 0.4, clouds: 0.3, rain: 0.15, thunderstorm: 0.1, drizzle: 0.05 }
                    : { clear: 0.3, clouds: 0.35, rain: 0.25, drizzle: 0.1 };
            }
            // Subtropical (15-30¬∞)
            else if (absLat > 15) {
                baseTemp = 25;
                tempVariation = 5;
                weatherProbs = { clear: 0.5, clouds: 0.25, rain: 0.15, thunderstorm: 0.08, drizzle: 0.02 };
            }
            // Tropical (0-15¬∞)
            else {
                baseTemp = 28;
                tempVariation = 3;
                weatherProbs = { clear: 0.35, clouds: 0.25, rain: 0.25, thunderstorm: 0.15 };
            }

            // Add random variation
            const temp = Math.round(baseTemp + (Math.random() - 0.5) * tempVariation);

            // Select weather based on probabilities
            const rand = Math.random();
            let cumulative = 0;
            let weatherType = 'clear';
            for (const [type, prob] of Object.entries(weatherProbs)) {
                cumulative += prob;
                if (rand <= cumulative) {
                    weatherType = type;
                    break;
                }
            }

            // Adjust humidity based on climate
            const baseHumidity = absLat < 15 ? 75 : absLat < 30 ? 60 : absLat < 45 ? 55 : 50;
            const humidity = Math.round(baseHumidity + (Math.random() - 0.5) * 20);

            // Wind speed varies by latitude (higher at temperate zones)
            const baseWind = absLat > 40 && absLat < 60 ? 20 : 10;
            const windSpeed = Math.round(baseWind + Math.random() * 15);

            return {
                temp: temp,
                feelsLike: temp + Math.round((Math.random() - 0.5) * 4),
                humidity: Math.max(20, Math.min(100, humidity)),
                pressure: Math.round(1000 + (Math.random() - 0.5) * 30),
                windSpeed: windSpeed,
                windDirection: Math.round(Math.random() * 360),
                cloudiness: weatherType.includes('cloud') || weatherType.includes('rain')
                    ? Math.round(60 + Math.random() * 40)
                    : Math.round(Math.random() * 30),
                visibility: weatherType === 'mist' || weatherType === 'fog'
                    ? Math.round(2 + Math.random() * 3)
                    : Math.round(8 + Math.random() * 7),
                weather: weatherType,
                description: getWeatherDescription(weatherType),
                forecast: generateForecast(city.lat)
            };
        }

        function getWeatherDescription(type) {
            const descriptions = {
                clear: 'Clear sky',
                clouds: 'Partly cloudy',
                rain: 'Moderate rain',
                snow: 'Light snow',
                thunderstorm: 'Thunderstorm',
                drizzle: 'Light drizzle',
                mist: 'Misty',
                fog: 'Foggy'
            };
            return descriptions[type] || 'Clear';
        }

        function generateForecast(lat) {
            const days = ['Tomorrow', 'Day 3', 'Day 4', 'Day 5'];
            const absLat = Math.abs(lat);

            // Base temperature range by latitude
            let baseHigh, baseLow, weatherOptions;

            if (absLat > 66) {
                // Arctic/Antarctic
                baseHigh = 0; baseLow = -15;
                weatherOptions = ['clear', 'clouds', 'snow'];
            } else if (absLat > 45) {
                // Cold temperate
                baseHigh = 18; baseLow = 5;
                weatherOptions = ['clear', 'clouds', 'rain', 'snow'];
            } else if (absLat > 30) {
                // Temperate
                baseHigh = 25; baseLow = 12;
                weatherOptions = ['clear', 'clouds', 'rain'];
            } else if (absLat > 15) {
                // Subtropical
                baseHigh = 28; baseLow = 18;
                weatherOptions = ['clear', 'clouds', 'rain'];
            } else {
                // Tropical
                baseHigh = 31; baseLow = 23;
                weatherOptions = ['clear', 'clouds', 'rain', 'thunderstorm'];
            }

            return days.map(day => {
                const high = Math.round(baseHigh + (Math.random() - 0.5) * 6);
                const low = Math.round(baseLow + (Math.random() - 0.5) * 6);
                return {
                    day: day,
                    high: high,
                    low: Math.min(low, high - 3), // Ensure low is less than high
                    weather: weatherOptions[Math.floor(Math.random() * weatherOptions.length)]
                };
            });
        }

        // ====================================
        // PROCEDURAL TEXTURES
        // ====================================
        function createEarthTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Helper function to convert lat/lon to canvas coordinates
            function latLonToCanvas(lat, lon) {
                // Longitude: -180 to 180 maps to 0 to 1024
                const x = ((lon + 180) / 360) * canvas.width;
                // Latitude: 90 to -90 maps to 0 to 512
                const y = ((90 - lat) / 180) * canvas.height;
                return { x, y };
            }

            // Ocean background with depth gradient
            const oceanGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            oceanGradient.addColorStop(0, '#1a5f8a');
            oceanGradient.addColorStop(0.3, '#1e6ba8');
            oceanGradient.addColorStop(0.5, '#2777c4');
            oceanGradient.addColorStop(0.7, '#1e6ba8');
            oceanGradient.addColorStop(1, '#1a5f8a');
            ctx.fillStyle = oceanGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Add ocean texture
            for (let i = 0; i < 8000; i++) {
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.08})`;
                ctx.fillRect(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height,
                    2, 2
                );
            }

            // Land color
            ctx.fillStyle = '#2d5a1e';
            ctx.strokeStyle = '#2d5a1e';

            // NORTH AMERICA
            ctx.beginPath();
            ctx.ellipse(200, 130, 90, 70, -0.2, 0, Math.PI * 2);
            ctx.fill();
            // Canada extension
            ctx.beginPath();
            ctx.ellipse(140, 90, 70, 50, -0.3, 0, Math.PI * 2);
            ctx.fill();
            // Alaska
            ctx.beginPath();
            ctx.ellipse(50, 100, 35, 30, 0.2, 0, Math.PI * 2);
            ctx.fill();
            // Eastern seaboard
            ctx.beginPath();
            ctx.ellipse(260, 150, 30, 40, 0, 0, Math.PI * 2);
            ctx.fill();
            // Mexico/Central America
            ctx.beginPath();
            ctx.moveTo(180, 200);
            ctx.quadraticCurveTo(200, 220, 210, 240);
            ctx.quadraticCurveTo(200, 245, 195, 250);
            ctx.quadraticCurveTo(185, 240, 175, 230);
            ctx.quadraticCurveTo(170, 210, 180, 200);
            ctx.fill();

            // SOUTH AMERICA
            ctx.beginPath();
            ctx.ellipse(250, 310, 55, 95, 0.15, 0, Math.PI * 2);
            ctx.fill();
            // Northern extension (Venezuela/Colombia)
            ctx.beginPath();
            ctx.ellipse(260, 250, 30, 25, 0, 0, Math.PI * 2);
            ctx.fill();

            // EUROPE
            ctx.beginPath();
            ctx.ellipse(512, 120, 70, 45, 0, 0, Math.PI * 2);
            ctx.fill();
            // Scandinavia
            ctx.beginPath();
            ctx.ellipse(530, 85, 35, 50, 0.2, 0, Math.PI * 2);
            ctx.fill();
            // Iberian Peninsula
            ctx.beginPath();
            ctx.ellipse(485, 150, 20, 25, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // AFRICA
            ctx.beginPath();
            ctx.ellipse(535, 240, 75, 70, 0, 0, Math.PI * 2);
            ctx.fill();
            // Northern Africa extension
            ctx.beginPath();
            ctx.ellipse(520, 190, 65, 35, 0, 0, Math.PI * 2);
            ctx.fill();
            // Southern Africa
            ctx.beginPath();
            ctx.ellipse(545, 340, 45, 50, 0, 0, Math.PI * 2);
            ctx.fill();
            // Madagascar
            ctx.beginPath();
            ctx.ellipse(600, 330, 12, 25, 0, 0, Math.PI * 2);
            ctx.fill();

            // ASIA
            // Western Asia / Middle East
            ctx.beginPath();
            ctx.ellipse(590, 160, 50, 40, 0, 0, Math.PI * 2);
            ctx.fill();
            // Central Asia
            ctx.beginPath();
            ctx.ellipse(670, 145, 70, 45, 0, 0, Math.PI * 2);
            ctx.fill();
            // Siberia
            ctx.beginPath();
            ctx.ellipse(730, 100, 110, 55, 0, 0, Math.PI * 2);
            ctx.fill();
            // Eastern Siberia
            ctx.beginPath();
            ctx.ellipse(850, 95, 80, 50, 0, 0, Math.PI * 2);
            ctx.fill();
            // India
            ctx.beginPath();
            ctx.ellipse(680, 210, 35, 45, 0, 0, Math.PI * 2);
            ctx.fill();
            // Southeast Asia
            ctx.beginPath();
            ctx.ellipse(750, 220, 45, 35, 0.2, 0, Math.PI * 2);
            ctx.fill();
            // China
            ctx.beginPath();
            ctx.ellipse(780, 165, 70, 55, 0, 0, Math.PI * 2);
            ctx.fill();
            // Japan
            ctx.beginPath();
            ctx.ellipse(870, 160, 15, 40, 0.3, 0, Math.PI * 2);
            ctx.fill();
            // Korean Peninsula
            ctx.beginPath();
            ctx.ellipse(835, 155, 10, 20, 0, 0, Math.PI * 2);
            ctx.fill();

            // SOUTHEAST ASIAN ISLANDS
            // Indonesia/Malaysia
            ctx.beginPath();
            ctx.ellipse(770, 260, 55, 20, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(820, 270, 40, 15, 0.1, 0, Math.PI * 2);
            ctx.fill();
            // Philippines
            ctx.beginPath();
            ctx.ellipse(815, 225, 15, 30, 0, 0, Math.PI * 2);
            ctx.fill();

            // AUSTRALIA
            ctx.beginPath();
            ctx.ellipse(850, 345, 60, 45, 0, 0, Math.PI * 2);
            ctx.fill();
            // Tasmania
            ctx.beginPath();
            ctx.ellipse(870, 390, 12, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // NEW ZEALAND
            ctx.beginPath();
            ctx.ellipse(950, 380, 10, 30, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // ANTARCTICA (bottom edge)
            ctx.fillRect(0, 450, canvas.width, 62);

            // GREENLAND
            ctx.beginPath();
            ctx.ellipse(420, 80, 40, 55, -0.2, 0, Math.PI * 2);
            ctx.fill();

            // UK/Ireland
            ctx.beginPath();
            ctx.ellipse(490, 105, 15, 25, 0, 0, Math.PI * 2);
            ctx.fill();

            // POLAR ICE CAPS
            // Arctic ice cap
            const arcticGradient = ctx.createRadialGradient(canvas.width / 2, 0, 0, canvas.width / 2, 0, 100);
            arcticGradient.addColorStop(0, '#f0f8ff');
            arcticGradient.addColorStop(0.4, '#e6f2ff');
            arcticGradient.addColorStop(0.7, '#d0e8ff');
            arcticGradient.addColorStop(1, 'rgba(208, 232, 255, 0)');
            ctx.fillStyle = arcticGradient;
            ctx.fillRect(0, 0, canvas.width, 80);

            // Antarctic ice cap (larger and more prominent)
            const antarcticGradient = ctx.createRadialGradient(canvas.width / 2, canvas.height, 0, canvas.width / 2, canvas.height, 120);
            antarcticGradient.addColorStop(0, '#ffffff');
            antarcticGradient.addColorStop(0.3, '#f5f9ff');
            antarcticGradient.addColorStop(0.6, '#e8f0ff');
            antarcticGradient.addColorStop(1, 'rgba(232, 240, 255, 0)');
            ctx.fillStyle = antarcticGradient;
            ctx.fillRect(0, canvas.height - 100, canvas.width, 100);

            // Greenland ice (white overlay)
            ctx.fillStyle = '#f5f9ff';
            ctx.globalAlpha = 0.7;
            ctx.beginPath();
            ctx.ellipse(420, 80, 35, 50, -0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;

            // Add varied terrain texture
            const landColors = ['#2d5a1e', '#3a6b24', '#2a5018', '#356320'];
            for (let i = 0; i < 5000; i++) {
                ctx.fillStyle = landColors[Math.floor(Math.random() * landColors.length)];
                const size = Math.random() * 3 + 1;
                ctx.fillRect(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height,
                    size, size
                );
            }

            // Add subtle coastline highlight
            ctx.strokeStyle = 'rgba(100, 150, 80, 0.3)';
            ctx.lineWidth = 2;
            // This would outline major landmasses - simplified for performance

            return new THREE.CanvasTexture(canvas);
        }

        function createCloudTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Helper to draw cloud cluster
            function drawCloudCluster(x, y, size, density, opacity) {
                for (let i = 0; i < density; i++) {
                    const offsetX = (Math.random() - 0.5) * size;
                    const offsetY = (Math.random() - 0.5) * size * 0.6;
                    const cloudX = (x + offsetX + canvas.width) % canvas.width;
                    const cloudY = Math.max(0, Math.min(canvas.height, y + offsetY));
                    const radius = 15 + Math.random() * 30;

                    const gradient = ctx.createRadialGradient(cloudX, cloudY, 0, cloudX, cloudY, radius);
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${opacity * 0.9})`);
                    gradient.addColorStop(0.5, `rgba(255, 255, 255, ${opacity * 0.5})`);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                    ctx.fillStyle = gradient;
                    ctx.fillRect(cloudX - radius, cloudY - radius, radius * 2, radius * 2);
                }
            }

            // Intertropical Convergence Zone (ITCZ) - heavy clouds near equator
            const itczY = canvas.height * 0.55; // Slightly south of equator
            for (let x = 0; x < canvas.width; x += 60) {
                drawCloudCluster(x + Math.random() * 60, itczY, 80, 15, 0.7);
            }

            // Mid-latitude storm tracks (30-60¬∞ latitude)
            // Northern hemisphere
            const northStormY = canvas.height * 0.25;
            for (let x = 0; x < canvas.width; x += 80) {
                if (Math.random() > 0.3) {
                    drawCloudCluster(x + Math.random() * 80, northStormY + (Math.random() - 0.5) * 40, 100, 12, 0.6);
                }
            }

            // Southern hemisphere
            const southStormY = canvas.height * 0.75;
            for (let x = 0; x < canvas.width; x += 80) {
                if (Math.random() > 0.3) {
                    drawCloudCluster(x + Math.random() * 80, southStormY + (Math.random() - 0.5) * 40, 100, 12, 0.6);
                }
            }

            // Subtropical regions (20-35¬∞ latitude) - less cloudy
            const subtropNorthY = canvas.height * 0.35;
            const subtropSouthY = canvas.height * 0.65;
            for (let x = 0; x < canvas.width; x += 120) {
                if (Math.random() > 0.6) {
                    drawCloudCluster(x + Math.random() * 120, subtropNorthY, 60, 8, 0.5);
                }
                if (Math.random() > 0.6) {
                    drawCloudCluster(x + Math.random() * 120, subtropSouthY, 60, 8, 0.5);
                }
            }

            // Polar regions - sparse clouds
            const arcticY = canvas.height * 0.1;
            const antarcticY = canvas.height * 0.9;
            for (let x = 0; x < canvas.width; x += 100) {
                if (Math.random() > 0.5) {
                    drawCloudCluster(x + Math.random() * 100, arcticY, 70, 6, 0.6);
                    drawCloudCluster(x + Math.random() * 100, antarcticY, 70, 6, 0.6);
                }
            }

            // Random scattered clouds
            for (let i = 0; i < 30; i++) {
                drawCloudCluster(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height,
                    50,
                    5,
                    0.4
                );
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createNightTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // City lights positioned on actual population centers
            const cityLightRegions = [
                // North America - East Coast
                { x: 260, y: 150, spread: 40, density: 80, color: '#ffdd66' },
                // North America - West Coast
                { x: 180, y: 155, spread: 35, density: 60, color: '#ffdd66' },
                // North America - Great Lakes
                { x: 220, y: 145, spread: 30, density: 50, color: '#ffdd66' },
                // Mexico City area
                { x: 200, y: 210, spread: 20, density: 40, color: '#ffdd66' },
                // South America - S√£o Paulo/Rio
                { x: 270, y: 320, spread: 25, density: 50, color: '#ffcc55' },
                // Europe - Western
                { x: 500, y: 125, spread: 60, density: 100, color: '#ffe680' },
                // Europe - UK
                { x: 490, y: 105, spread: 15, density: 30, color: '#ffe680' },
                // Europe - Mediterranean
                { x: 520, y: 145, spread: 40, density: 60, color: '#ffe680' },
                // Middle East
                { x: 590, y: 165, spread: 35, density: 40, color: '#ffcc55' },
                // Africa - North (Cairo, etc.)
                { x: 535, y: 195, spread: 25, density: 30, color: '#ffbb44' },
                // Africa - Nigeria
                { x: 505, y: 235, spread: 15, density: 25, color: '#ffbb44' },
                // Africa - South
                { x: 545, y: 340, spread: 20, density: 25, color: '#ffbb44' },
                // India
                { x: 680, y: 210, spread: 40, density: 70, color: '#ffcc55' },
                // Southeast Asia - Bangkok
                { x: 750, y: 220, spread: 25, density: 40, color: '#ffcc55' },
                // China - Eastern
                { x: 810, y: 165, spread: 50, density: 90, color: '#ffe680' },
                // China - Beijing area
                { x: 800, y: 155, spread: 30, density: 60, color: '#ffe680' },
                // Japan
                { x: 870, y: 160, spread: 20, density: 50, color: '#ffe680' },
                // Korea
                { x: 835, y: 155, spread: 12, density: 35, color: '#ffe680' },
                // Indonesia
                { x: 780, y: 260, spread: 30, density: 40, color: '#ffcc55' },
                // Australia - East Coast
                { x: 880, y: 345, spread: 30, density: 40, color: '#ffdd66' },
                // Australia - Perth
                { x: 800, y: 350, spread: 12, density: 20, color: '#ffdd66' },
                // Russia - Moscow
                { x: 575, y: 110, spread: 20, density: 35, color: '#ffcc55' },
                // Russia - Siberia cities
                { x: 700, y: 110, spread: 40, density: 25, color: '#ffbb44' }
            ];

            cityLightRegions.forEach(region => {
                ctx.fillStyle = region.color;
                ctx.shadowBlur = 3;
                ctx.shadowColor = region.color;

                for (let i = 0; i < region.density; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * region.spread;
                    const x = region.x + Math.cos(angle) * distance;
                    const y = region.y + Math.sin(angle) * distance;
                    const size = 0.5 + Math.random() * 2;

                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Add some scattered lights in less dense areas
            ctx.fillStyle = '#ffaa33';
            for (let i = 0; i < 200; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                ctx.beginPath();
                ctx.arc(x, y, 0.5, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.shadowBlur = 0;
            return new THREE.CanvasTexture(canvas);
        }

        // ====================================
        // 3D SCENE SETUP
        // ====================================
        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 3;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Raycaster for click detection
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            // Main sun light
            const sunLight = new THREE.DirectionalLight(0xffffee, 1.2);
            sunLight.position.set(5, 2, 3);
            scene.add(sunLight);

            // Subtle fill light from opposite side
            const fillLight = new THREE.DirectionalLight(0x4466ff, 0.3);
            fillLight.position.set(-3, -1, -2);
            scene.add(fillLight);

            // Rim light for atmosphere
            const rimLight = new THREE.DirectionalLight(0x88ccff, 0.4);
            rimLight.position.set(-5, 0, -5);
            scene.add(rimLight);

            // Create starfield
            createStarfield();

            // Create Earth globe
            createGlobe();

            // Create cloud layer
            createClouds();

            // Create atmosphere
            createAtmosphere();

            // Create city markers
            createCityMarkers();

            // Event listeners
            setupEventListeners();

            // Hide loading
            document.getElementById('loading').style.display = 'none';

            // Start animation
            animate();
        }

        function createStarfield() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.7,
                transparent: true
            });

            const starsVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);
            }

            starsGeometry.setAttribute('position',
                new THREE.Float32BufferAttribute(starsVertices, 3));

            stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }

        function createGlobe() {
            const geometry = new THREE.SphereGeometry(1, 128, 128);

            // Create material with textures
            const dayTexture = createEarthTexture();
            const nightTexture = createNightTexture();

            const material = new THREE.MeshPhongMaterial({
                map: dayTexture,
                emissiveMap: nightTexture,
                emissive: new THREE.Color(0xffee88),
                emissiveIntensity: 0.25,
                shininess: 10,
                specular: new THREE.Color(0x333333),
                transparent: false,
                bumpScale: 0.005
            });

            globe = new THREE.Mesh(geometry, material);
            globe.userData.dayTexture = dayTexture;
            globe.userData.nightTexture = nightTexture;
            scene.add(globe);
        }

        function createClouds() {
            const geometry = new THREE.SphereGeometry(1.01, 64, 64);
            const cloudTexture = createCloudTexture();

            const material = new THREE.MeshPhongMaterial({
                map: cloudTexture,
                transparent: true,
                opacity: 0.4,
                depthWrite: false
            });

            clouds = new THREE.Mesh(geometry, material);
            scene.add(clouds);
        }

        function createAtmosphere() {
            const geometry = new THREE.SphereGeometry(1.12, 64, 64);
            const material = new THREE.ShaderMaterial({
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    void main() {
                        float intensity = pow(0.65 - dot(vNormal, vec3(0, 0, 1.0)), 2.5);

                        // Create atmospheric color gradient (blue at edges, lighter at top)
                        vec3 atmosphereColor = mix(
                            vec3(0.3, 0.6, 1.0),  // Blue
                            vec3(0.5, 0.7, 1.0),  // Lighter blue
                            smoothstep(-0.5, 0.5, vPosition.y)
                        );

                        gl_FragColor = vec4(atmosphereColor, 1.0) * intensity;
                    }
                `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true
            });

            atmosphere = new THREE.Mesh(geometry, material);
            scene.add(atmosphere);
        }

        function createCityMarkers() {
            cityData.forEach(cityInfo => {
                const position = latLonToVector3(cityInfo.lat, cityInfo.lon, 1.02);

                // Create marker
                const markerGeometry = new THREE.SphereGeometry(0.01, 16, 16);
                const markerMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff6b6b,
                    transparent: true,
                    opacity: 0.9
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.copy(position);

                // Create glow
                const glowGeometry = new THREE.SphereGeometry(0.015, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff6b6b,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(position);

                // Store city info
                marker.userData = {
                    cityInfo: cityInfo,
                    weather: generateWeatherData(cityInfo),
                    glow: glow
                };

                globe.add(marker);
                globe.add(glow);
                cityMarkers.push(marker);
                cities.push({...cityInfo, marker: marker});
            });
        }

        // ====================================
        // TEMPERATURE VISUALIZATION
        // ====================================
        function updateTemperatureVisualization() {
            if (showTemperature) {
                cityMarkers.forEach(marker => {
                    const temp = marker.userData.weather.temp;
                    const color = getTemperatureColor(temp);
                    marker.material.color.copy(color);
                    marker.userData.glow.material.color.copy(color);
                });
            } else {
                cityMarkers.forEach(marker => {
                    marker.material.color.set(0xff6b6b);
                    marker.userData.glow.material.color.set(0xff6b6b);
                });
            }
        }

        // ====================================
        // EVENT HANDLERS
        // ====================================
        function setupEventListeners() {
            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Mouse events
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('click', onClick);

            // Touch events
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            renderer.domElement.addEventListener('touchend', onTouchEnd);

            // Search
            document.getElementById('search-input').addEventListener('input', onSearchInput);

            // Controls
            document.getElementById('auto-rotate-btn').addEventListener('click', toggleAutoRotate);
            document.getElementById('clouds-btn').addEventListener('click', toggleClouds);
            document.getElementById('day-night-btn').addEventListener('click', toggleDayNight);
            document.getElementById('temperature-btn').addEventListener('click', toggleTemperature);
            document.getElementById('reset-btn').addEventListener('click', resetView);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseDown(event) {
            controls.isDragging = true;
            controls.previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onMouseMove(event) {
            // Tooltip
            updateTooltip(event);

            if (!controls.isDragging) return;

            const deltaMove = {
                x: event.clientX - controls.previousMousePosition.x,
                y: event.clientY - controls.previousMousePosition.y
            };

            controls.rotationSpeed.x = deltaMove.y * 0.01;
            controls.rotationSpeed.y = deltaMove.x * 0.01;

            globe.rotation.y += controls.rotationSpeed.y;
            globe.rotation.x += controls.rotationSpeed.x;

            controls.previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onMouseUp(event) {
            controls.isDragging = false;
        }

        function onMouseWheel(event) {
            event.preventDefault();
            const delta = event.deltaY * 0.001;
            camera.position.z = Math.max(1.5, Math.min(5, camera.position.z + delta));
        }

        function onTouchStart(event) {
            if (event.touches.length === 1) {
                controls.isDragging = true;
                controls.previousMousePosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            }
        }

        function onTouchMove(event) {
            if (!controls.isDragging || event.touches.length !== 1) return;

            const deltaMove = {
                x: event.touches[0].clientX - controls.previousMousePosition.x,
                y: event.touches[0].clientY - controls.previousMousePosition.y
            };

            controls.rotationSpeed.x = deltaMove.y * 0.01;
            controls.rotationSpeed.y = deltaMove.x * 0.01;

            globe.rotation.y += controls.rotationSpeed.y;
            globe.rotation.x += controls.rotationSpeed.x;

            controls.previousMousePosition = {
                x: event.touches[0].clientX,
                y: event.touches[0].clientY
            };
        }

        function onTouchEnd(event) {
            controls.isDragging = false;
        }

        function onClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cityMarkers);

            if (intersects.length > 0) {
                const marker = intersects[0].object;
                selectCity(marker.userData.cityInfo, marker.userData.weather);
                zoomToCity(marker);
            }
        }

        function updateTooltip(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cityMarkers);

            const tooltip = document.getElementById('tooltip');

            if (intersects.length > 0) {
                const marker = intersects[0].object;
                const cityInfo = marker.userData.cityInfo;
                const weather = marker.userData.weather;

                tooltip.innerHTML = `
                    <strong>${cityInfo.name}</strong><br>
                    ${weather.temp}¬∞C - ${weather.description}
                `;
                tooltip.style.display = 'block';
                tooltip.style.left = event.clientX + 10 + 'px';
                tooltip.style.top = event.clientY + 10 + 'px';
            } else {
                tooltip.style.display = 'none';
            }
        }

        function onSearchInput(event) {
            const query = event.target.value.toLowerCase();
            const resultsContainer = document.getElementById('search-results');

            if (query.length < 2) {
                resultsContainer.innerHTML = '';
                return;
            }

            const results = cities.filter(city =>
                city.name.toLowerCase().includes(query) ||
                city.country.toLowerCase().includes(query)
            );

            resultsContainer.innerHTML = results.map(city => `
                <div class="search-result-item" data-city="${city.name}">
                    ${city.name}, ${city.country}
                </div>
            `).join('');

            // Add click handlers
            resultsContainer.querySelectorAll('.search-result-item').forEach(item => {
                item.addEventListener('click', () => {
                    const cityName = item.dataset.city;
                    const city = cities.find(c => c.name === cityName);
                    if (city) {
                        selectCity(city, city.marker.userData.weather);
                        zoomToCity(city.marker);
                        resultsContainer.innerHTML = '';
                        document.getElementById('search-input').value = '';
                    }
                });
            });
        }

        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            document.getElementById('auto-rotate-btn').classList.toggle('active');
        }

        function toggleClouds() {
            showClouds = !showClouds;
            clouds.visible = showClouds;
            document.getElementById('clouds-btn').classList.toggle('active');
        }

        function toggleDayNight() {
            showDayNight = !showDayNight;
            globe.material.emissiveIntensity = showDayNight ? 0.2 : 0;
            document.getElementById('day-night-btn').classList.toggle('active');
        }

        function toggleTemperature() {
            showTemperature = !showTemperature;
            updateTemperatureVisualization();
            document.getElementById('temperature-btn').classList.toggle('active');
        }

        function resetView() {
            camera.position.set(0, 0, 3);
            globe.rotation.set(0, 0, 0);
            controls.rotationSpeed = { x: 0, y: 0 };
            document.getElementById('weather-info').classList.remove('active');
            selectedCity = null;
        }

        // ====================================
        // CITY SELECTION AND ZOOM
        // ====================================
        function selectCity(cityInfo, weather) {
            selectedCity = cityInfo;

            const weatherInfoPanel = document.getElementById('weather-info');
            weatherInfoPanel.classList.add('active');

            weatherInfoPanel.innerHTML = `
                <div class="weather-header">
                    <h2>${cityInfo.name}</h2>
                    <div class="country">${cityInfo.country}</div>
                </div>

                <div class="current-weather">
                    <div class="weather-icon">${weatherIcons[weather.weather] || '‚òÄÔ∏è'}</div>
                    <div class="temperature">${weather.temp}¬∞C</div>
                    <div class="weather-description">${weather.description}</div>

                    <div class="weather-details">
                        <div class="weather-detail">
                            <div class="weather-detail-label">Feels Like</div>
                            <div class="weather-detail-value">${weather.feelsLike}¬∞C</div>
                        </div>
                        <div class="weather-detail">
                            <div class="weather-detail-label">Humidity</div>
                            <div class="weather-detail-value">${weather.humidity}%</div>
                        </div>
                        <div class="weather-detail">
                            <div class="weather-detail-label">Wind</div>
                            <div class="weather-detail-value">${weather.windSpeed} km/h</div>
                        </div>
                        <div class="weather-detail">
                            <div class="weather-detail-label">Pressure</div>
                            <div class="weather-detail-value">${weather.pressure} hPa</div>
                        </div>
                        <div class="weather-detail">
                            <div class="weather-detail-label">Visibility</div>
                            <div class="weather-detail-value">${weather.visibility} km</div>
                        </div>
                        <div class="weather-detail">
                            <div class="weather-detail-label">Cloudiness</div>
                            <div class="weather-detail-value">${weather.cloudiness}%</div>
                        </div>
                    </div>
                </div>

                <div class="forecast-section">
                    <h3>5-Day Forecast</h3>
                    <div class="forecast-cards">
                        ${weather.forecast.map(day => `
                            <div class="forecast-card">
                                <div>
                                    <div class="forecast-day">${day.day}</div>
                                    <div>${weatherIcons[day.weather] || '‚òÄÔ∏è'}</div>
                                </div>
                                <div class="forecast-temps">
                                    <span class="forecast-high">${day.high}¬∞</span>
                                    <span class="forecast-low">${day.low}¬∞</span>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function zoomToCity(marker) {
            const targetPosition = marker.position.clone();
            targetPosition.multiplyScalar(2.5);

            // Animate camera
            const startPosition = camera.position.clone();
            const startRotation = globe.rotation.clone();

            // Calculate target rotation to face the city
            const cityLat = marker.userData.cityInfo.lat;
            const cityLon = marker.userData.cityInfo.lon;
            const targetRotationY = -(cityLon * Math.PI / 180);
            const targetRotationX = (cityLat * Math.PI / 180) - Math.PI / 2;

            let progress = 0;
            const duration = 1500;
            const startTime = Date.now();

            function animateZoom() {
                const elapsed = Date.now() - startTime;
                progress = Math.min(elapsed / duration, 1);

                // Easing function
                const eased = 1 - Math.pow(1 - progress, 3);

                // Interpolate rotation
                globe.rotation.y = startRotation.y + (targetRotationY - startRotation.y) * eased;
                globe.rotation.x = startRotation.x + (targetRotationX - startRotation.x) * eased;

                if (progress < 1) {
                    requestAnimationFrame(animateZoom);
                }
            }

            animateZoom();
        }

        // ====================================
        // ANIMATION LOOP
        // ====================================
        function animate() {
            requestAnimationFrame(animate);

            // Auto-rotate
            if (autoRotate && !controls.isDragging) {
                globe.rotation.y += 0.001;
            }

            // Rotate clouds slightly faster
            if (clouds && showClouds) {
                clouds.rotation.y += 0.0005;
            }

            // Rotate starfield slowly
            if (stars) {
                stars.rotation.y += 0.0001;
            }

            // Pulse city markers
            const time = Date.now() * 0.001;
            cityMarkers.forEach((marker, index) => {
                const scale = 1 + Math.sin(time * 2 + index * 0.5) * 0.3;
                marker.userData.glow.scale.set(scale, scale, scale);
            });

            renderer.render(scene, camera);
        }

        // ====================================
        // INITIALIZE
        // ====================================
        init();
    </script>
</body>
</html>