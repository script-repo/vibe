<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ePub Reader with Natural TTS</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --primary-a: #667eea;
      --primary-b: #764ba2;
      --bg: linear-gradient(135deg, var(--primary-a) 0%, var(--primary-b) 100%);
      --glass: rgba(255, 255, 255, 0.95);
      --shadow: 0 20px 60px rgba(0,0,0,.3);
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: var(--bg);
      min-height: 100vh; display: flex; justify-content: center; align-items: center; padding: 20px;
    }
    .container {
      background: var(--glass); backdrop-filter: blur(10px); border-radius: 20px; box-shadow: var(--shadow);
      max-width: 980px; width: 100%; padding: 24px; animation: fadeIn .5s ease-out;
    }
    @keyframes fadeIn { from {opacity:0; transform: translateY(12px)} to {opacity:1; transform: translateY(0)} }
    h1 {
      color:#333; text-align:center; margin-bottom: 18px; font-size: clamp(1.4rem, 2.6vw, 2.4rem);
      background: linear-gradient(135deg, var(--primary-a), var(--primary-b));
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
    }
    .upload-section { margin-bottom: 14px; }
    .file-input-wrapper { position: relative; overflow: hidden; display: inline-block; width: 100%; }
    .file-input-wrapper input[type=file] { position: absolute; left: -9999px; }
    .file-input-label {
      display: block; padding: 12px 18px; background: linear-gradient(135deg, var(--primary-a), var(--primary-b));
      color: #fff; border-radius: 10px; cursor: pointer; text-align: center; font-size: 1rem; font-weight: 600;
      transition: all .25s ease; box-shadow: 0 4px 15px rgba(102,126,234,.35);
    }
    .file-input-label:hover { transform: translateY(-1px); box-shadow: 0 6px 20px rgba(102,126,234,.45); }
    .row { display: grid; grid-template-columns: repeat(12, 1fr); gap: 12px; }
    .card {
      background: #f8f9fa; border-radius: 14px; padding: 14px; display: none;
    }
    .card.active { display: block; }
    .control-row { display:flex; align-items:center; gap:10px; flex-wrap: wrap; margin-bottom: 10px; }
    .control-row:last-child { margin-bottom: 0; }
    label { color:#555; font-weight: 600; }
    select, input[type="text"] {
      appearance: none; border: 2px solid #e5e7eb; background:#fff; border-radius: 10px; padding: 10px 12px; font-size: .95rem;
    }
    button {
      padding: 10px 14px; border: none; border-radius: 10px; font-weight: 700; cursor: pointer;
      transition: transform .15s ease, box-shadow .15s ease; box-shadow: 0 2px 8px rgba(0,0,0,.1);
    }
    .btn-primary { background: linear-gradient(135deg, var(--primary-a), var(--primary-b)); color:#fff; }
    .btn-primary:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(102,126,234,.35); }
    .btn-secondary { background:#fff; color: var(--primary-a); border: 2px solid var(--primary-a); }
    .btn-secondary:hover:not(:disabled) { background: var(--primary-a); color:#fff; }
    .btn-danger { background: #fff; color:#e74c3c; border:2px solid #e74c3c; }
    .btn-danger:hover { background:#e74c3c; color:#fff; }
    button:disabled { opacity:.55; cursor:not-allowed; }
    .speed-control { display:flex; align-items:center; gap:10px; flex: 1; min-width: 220px; }
    .speed-control input[type="range"] { flex: 1; height: 6px; border-radius: 3px; background:#ddd; outline:none; -webkit-appearance: none; }
    .speed-control input[type="range"]::-webkit-slider-thumb, .speed-control input[type="range"]::-moz-range-thumb {
      width: 18px; height: 18px; border-radius: 50%; background: linear-gradient(135deg, var(--primary-a), var(--primary-b));
      cursor: pointer; box-shadow: 0 2px 8px rgba(102,126,234,.35); border: none;
    }
    .speed-value { min-width: 52px; text-align: center; font-weight: 800; color: var(--primary-a); }
    .content-display {
      background:#fff; padding: 18px; border-radius: 14px; max-height: 50vh; overflow: auto; box-shadow: inset 0 2px 8px rgba(0,0,0,.05);
      display: none; line-height: 1.75;
    }
    .content-display.active { display:block; }
    .content-display h2 { color:#333; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 2px solid #f0f0f0; }
    .content-display p { color:#444; margin-bottom: 12px; }
    .content-display p.speaking {
      background: linear-gradient(90deg, rgba(102,126,234,.10) 0%, rgba(118,75,162,.10) 100%);
      border-left: 4px solid var(--primary-a);
      padding: 8px 12px; border-radius: 6px; animation: pulse 2s infinite;
    }
    @keyframes pulse { 0%,100% {opacity:1} 50% {opacity:.85} }
    .chapter-nav { display:flex; align-items:center; gap: 10px; }
    .chapter-info { flex:1; text-align:center; color:#666; font-weight:700; }
    .status { text-align:center; padding: 10px; margin-top: 10px; border-radius: 10px; font-weight: 700; display:none; }
    .status.active { display:block; }
    .status.speaking { background: linear-gradient(135deg, rgba(102,126,234,.10), rgba(118,75,162,.10)); color: var(--primary-a); }
    .status.paused { background: rgba(255,193,7,.10); color:#b7791f; }
    .status.stopped { background: rgba(231,76,60,.10); color:#c0392b; }
    .info { margin-top: 8px; padding: 10px; background:#f8f9fa; border-radius: 10px; color:#555; display:none; }
    .info.active { display:block; }
    .cover-image { 
      max-width: 120px; max-height: 180px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); 
      margin-right: 12px; float: left; object-fit: cover; 
    }
    .stack { display:flex; flex-wrap: wrap; gap: 10px; align-items:center; }
    .switch { display:inline-flex; align-items:center; gap:8px; user-select:none; }
    .switch input { width: 1.2rem; height: 1.2rem; }
    .muted { color:#6b7280; font-size: .9rem; }
    /* Responsive */
    @media (max-width: 900px) {
      .content-display { max-height: 55vh; }
    }
    @media (max-width: 640px) {
      .container { padding: 16px; }
      .chapter-nav { flex-wrap: wrap; }
      .content-display { max-height: 50vh; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üìö ePub Reader with Natural TTS</h1>

    <div class="upload-section">
      <div class="file-input-wrapper">
        <input type="file" id="fileInput" accept=".epub" />
        <label for="fileInput" class="file-input-label">üìñ Select ePub File</label>
      </div>
      <div id="fileInfo" class="info"></div>
    </div>

    <div id="controls" class="card">
      <!-- Chapter navigation -->
      <div class="control-row chapter-nav">
        <button id="prevChapter" class="btn-secondary">‚Üê Previous</button>
        <select id="chapterSelect" title="Jump to chapter"></select>
        <div id="chapterInfo" class="chapter-info">Chapter 1 of 1</div>
        <button id="nextChapter" class="btn-secondary">Next ‚Üí</button>
      </div>

      <!-- Transport controls -->
      <div class="control-row">
        <button id="playPause" class="btn-primary">‚ñ∂Ô∏è Play</button>
        <button id="stop" class="btn-primary">‚èπÔ∏è Stop</button>
        <button id="prevPara" class="btn-secondary">‚èÆÔ∏è Previous Paragraph</button>
        <button id="skip" class="btn-secondary">‚è≠Ô∏è Next Paragraph</button>
      </div>

      <!-- Voice & speed -->
      <div class="control-row">
        <div class="stack" style="flex:1">
          <label for="voiceSelect">Voice:</label>
          <select id="voiceSelect" style="min-width: 240px;"></select>
          <button id="refreshVoices" class="btn-secondary" title="Reload installed voices">üîÑ</button>
        </div>
        <div class="speed-control">
          <label for="speedSlider">Speed</label>
          <input type="range" id="speedSlider" min="0.5" max="3" step="0.1" value="1" />
          <span id="speedValue" class="speed-value">1.0x</span>
        </div>
      </div>

      <!-- Bookmarks -->
      <div class="control-row">
        <div class="stack" style="flex:1">
          <input id="bookmarkName" type="text" placeholder="Bookmark name (optional)" />
          <button id="addBookmark" class="btn-secondary">‚≠ê Add Bookmark</button>
        </div>
        <div class="stack" style="flex:1">
          <label for="bookmarkList">Bookmarks:</label>
          <select id="bookmarkList" style="min-width: 220px;"></select>
          <button id="goBookmark" class="btn-secondary">Go</button>
          <button id="delBookmark" class="btn-danger">Delete</button>
        </div>
      </div>

      <!-- Background playback helpers -->
      <div class="control-row">
        <div class="switch">
          <input type="checkbox" id="keepAwake" />
          <label for="keepAwake">Keep screen awake (Wake Lock)</label>
        </div>
        <div class="muted">Media Session controls enabled for background playback (OS-dependent).</div>
      </div>
    </div>

    <div id="contentDisplay" class="content-display"></div>
    <div id="status" class="status"></div>
  </div>

  <script>
    // --- State ---
    let epubContent = [];
    let currentChapter = 0;
    let currentParagraph = 0;
    let isPlaying = false;
    let isPaused = false;
    let currentUtterance = null;
    let isSpeechSupported = false;
    let voices = [];
    let selectedVoice = null;
    let currentFile = null;
    let storageKey = null;
    let bookmarks = [];
    let wakeLock = null;

    const speechSynth = window.speechSynthesis;

    // --- Feature detection ---
    if ('speechSynthesis' in window && 'SpeechSynthesisUtterance' in window) {
      isSpeechSupported = true;
      // load voices async
      loadVoices();
      window.speechSynthesis.onvoiceschanged = () => loadVoices();
    } else {
      setTimeout(() => {
        alert('Text-to-Speech is not supported in your browser. Try Chrome, Safari, Edge, or Firefox on desktop.');
      }, 400);
    }

    // --- UI elements ---
    const els = {
      fileInput: document.getElementById('fileInput'),
      fileInfo: document.getElementById('fileInfo'),
      controls: document.getElementById('controls'),
      content: document.getElementById('contentDisplay'),
      status: document.getElementById('status'),
      playPause: document.getElementById('playPause'),
      stop: document.getElementById('stop'),
      skip: document.getElementById('skip'),
      prevPara: document.getElementById('prevPara'),
      prevChapter: document.getElementById('prevChapter'),
      nextChapter: document.getElementById('nextChapter'),
      chapterInfo: document.getElementById('chapterInfo'),
      chapterSelect: document.getElementById('chapterSelect'),
      speedSlider: document.getElementById('speedSlider'),
      speedValue: document.getElementById('speedValue'),
      voiceSelect: document.getElementById('voiceSelect'),
      refreshVoices: document.getElementById('refreshVoices'),
      bookmarkName: document.getElementById('bookmarkName'),
      addBookmark: document.getElementById('addBookmark'),
      bookmarkList: document.getElementById('bookmarkList'),
      goBookmark: document.getElementById('goBookmark'),
      delBookmark: document.getElementById('delBookmark'),
      keepAwake: document.getElementById('keepAwake'),
    };

    // --- Event bindings ---
    els.fileInput.addEventListener('change', handleFileSelect);
    els.playPause.addEventListener('click', togglePlayPause);
    els.stop.addEventListener('click', stopReading);
    els.skip.addEventListener('click', nextParagraph);
    els.prevPara.addEventListener('click', previousParagraph);
    els.prevChapter.addEventListener('click', previousChapter);
    els.nextChapter.addEventListener('click', nextChapter);
    els.speedSlider.addEventListener('input', updateSpeed);
    els.voiceSelect.addEventListener('change', onVoiceChange);
    els.refreshVoices.addEventListener('click', loadVoices);
    els.addBookmark.addEventListener('click', addBookmark);
    els.goBookmark.addEventListener('click', goBookmark);
    els.delBookmark.addEventListener('click', deleteBookmark);
    els.chapterSelect.addEventListener('change', (e) => jumpTo(parseInt(e.target.value, 10), 0));
    els.keepAwake.addEventListener('change', toggleWakeLock);

    window.addEventListener('beforeunload', () => {
      try { speechSynth.cancel(); } catch {}
      releaseWakeLock();
    });

    document.addEventListener('visibilitychange', () => {
      // Nudge Media Session state so OS shows playback UI when in background
      if (document.hidden && isPlaying) updateMediaPlaybackState('playing');
    });

    // --- File handling & ePub parsing ---
    async function handleFileSelect(ev) {
      const file = ev.target.files[0];
      if (!file) return;
      currentFile = file;
      storageKey = 'epubReader::' + (file.name || 'untitled');
      epubContent = []; currentChapter = 0; currentParagraph = 0; bookmarks = [];

      els.fileInfo.innerHTML = `üìÑ <strong>${file.name}</strong> ‚Ä¢ ${(file.size/1024).toFixed(1)} KB`;
      els.fileInfo.classList.add('active');

      try {
        const arrayBuffer = await file.arrayBuffer();
        const zip = await JSZip.loadAsync(arrayBuffer);
        // container.xml
        const containerXml = await zip.file('META-INF/container.xml').async('string');
        const parser = new DOMParser();
        const containerDoc = parser.parseFromString(containerXml, 'text/xml');
        const rootfilePath = containerDoc.querySelector('rootfile').getAttribute('full-path');
        // content.opf
        const contentOpf = await zip.file(rootfilePath).async('string');
        const opfDoc = parser.parseFromString(contentOpf, 'text/xml');

        const spine = opfDoc.querySelector('spine');
        const spineItems = Array.from(spine.querySelectorAll('itemref'));

        const manifest = opfDoc.querySelector('manifest');
        const manifestItems = {};
        manifest.querySelectorAll('item').forEach(item => {
          manifestItems[item.getAttribute('id')] = item.getAttribute('href');
        });

        const basePath = rootfilePath.substring(0, rootfilePath.lastIndexOf('/') + 1);

        // Extract cover image
        let coverImageSrc = null;
        try {
          // Look for cover in metadata
          const metadataItems = opfDoc.querySelectorAll('metadata meta[name="cover"]');
          let coverId = null;
          if (metadataItems.length > 0) {
            coverId = metadataItems[0].getAttribute('content');
          } else {
            // Fallback: look for items with "cover" in id or href
            const coverItem = manifest.querySelector('item[id*="cover"], item[href*="cover"]') || 
                             manifest.querySelector('item[media-type="image/jpeg"], item[media-type="image/png"]');
            if (coverItem) coverId = coverItem.getAttribute('id');
          }
          
          if (coverId && manifestItems[coverId]) {
            const coverPath = basePath + manifestItems[coverId];
            const coverFile = zip.file(coverPath);
            if (coverFile) {
              const coverBlob = await coverFile.async('blob');
              coverImageSrc = URL.createObjectURL(coverBlob);
            }
          }
        } catch (e) {
          console.log('Could not extract cover image:', e);
        }

        epubContent = [];
        for (const spineItem of spineItems) {
          const idref = spineItem.getAttribute('idref');
          const href = manifestItems[idref];
          if (!href) continue;
          const fullPath = basePath + href;
          const html = await zip.file(fullPath).async('string');
          const doc = parser.parseFromString(html, 'text/html');
          const body = doc.querySelector('body');
          if (!body) continue;

          const paragraphs = [];
          const textEls = body.querySelectorAll('p, h1, h2, h3, h4, h5, h6');
          textEls.forEach(el => {
            const text = (el.textContent || '').trim();
            if (text) paragraphs.push(text);
          });
          if (paragraphs.length > 0) {
            // Try to infer chapter title
            let title = 'Chapter ' + (epubContent.length + 1);
            const firstHeader = body.querySelector('h1,h2,h3');
            if (firstHeader && firstHeader.textContent.trim().length > 0) title = firstHeader.textContent.trim();
            epubContent.push({ title, paragraphs });
          }
        }

        if (epubContent.length === 0) {
          alert('No readable content found in the ePub file.');
          return;
        }

        // Update file info with cover
        let fileInfoHtml = `üìÑ <strong>${file.name}</strong> ‚Ä¢ ${(file.size/1024).toFixed(1)} KB`;
        if (coverImageSrc) {
          fileInfoHtml = `<img src="${coverImageSrc}" class="cover-image" alt="Book cover" />${fileInfoHtml}`;
        }
        els.fileInfo.innerHTML = fileInfoHtml;

        // Build chapter selector
        els.chapterSelect.innerHTML = epubContent.map((c, i) => `<option value="${i}">${i+1}. ${escapeHtml(c.title).slice(0,80)}</option>`).join('');
        displayChapter();
        els.controls.classList.add('active');
        updateChapterInfo();
        initMediaSession(file.name);

        // Load saved state
        const saved = loadState();
        if (saved) {
          bookmarks = saved.bookmarks || [];
          renderBookmarks();
          // Offer to resume
          const resume = confirm(`Resume "${file.name}" from Chapter ${saved.chapter+1}, Paragraph ${saved.paragraph+1}?`);
          if (resume) {
            jumpTo(saved.chapter, saved.paragraph);
            if (typeof saved.speed === 'number') {
              els.speedSlider.value = saved.speed.toFixed(1);
              els.speedValue.textContent = saved.speed.toFixed(1) + 'x';
            }
            // Restore voice if available
            if (saved.voiceURI && voices.length) {
              const v = voices.find(v => v.voiceURI === saved.voiceURI);
              if (v) {
                selectedVoice = v;
                els.voiceSelect.value = v.voiceURI;
              }
            }
          } else {
            renderBookmarks();
          }
        }

      } catch (err) {
        console.error(err);
        alert('Error reading ePub file. Ensure it is a valid .epub.');
      }
    }

    function displayChapter() {
      const chapter = epubContent[currentChapter];
      let html = `<h2>${escapeHtml(chapter.title)}</h2>`;
      chapter.paragraphs.forEach((p, idx) => {
        html += `<p id="para-${idx}">${escapeHtml(p)}</p>`;
      });
      els.content.innerHTML = html;
      els.content.classList.add('active');
      els.chapterSelect.value = String(currentChapter);
    }

    function updateChapterInfo() {
      els.chapterInfo.textContent = `Chapter ${currentChapter + 1} of ${epubContent.length}`;
      els.prevChapter.disabled = currentChapter === 0;
      els.nextChapter.disabled = currentChapter === epubContent.length - 1;
    }

    // --- Playback controls ---
    function togglePlayPause() {
      if (!isSpeechSupported) {
        alert('Text-to-Speech is not supported in your browser.');
        return;
      }
      if (isPlaying) {
        if (isPaused) {
          speechSynth.resume();
          isPaused = false;
          els.playPause.innerHTML = '‚è∏Ô∏è Pause';
          updateStatus('Speaking...', 'speaking'); updateMediaPlaybackState('playing');
        } else {
          speechSynth.pause();
          isPaused = true;
          els.playPause.innerHTML = '‚ñ∂Ô∏è Resume';
          updateStatus('Paused', 'paused'); updateMediaPlaybackState('paused');
        }
      } else {
        startReading();
      }
    }

    function startReading() {
      if (!isSpeechSupported || epubContent.length === 0) return;
      isPlaying = true; isPaused = false;
      els.playPause.innerHTML = '‚è∏Ô∏è Pause';
      updateStatus('Speaking...', 'speaking');
      updateMediaPlaybackState('playing');
      speakParagraph();
    }

    function speakParagraph() {
      if (!isSpeechSupported || !isPlaying || currentChapter >= epubContent.length) {
        stopReading(); return;
      }
      const chapter = epubContent[currentChapter];
      if (currentParagraph >= chapter.paragraphs.length) {
        // next chapter
        if (currentChapter < epubContent.length - 1) {
          currentChapter++; currentParagraph = 0;
          displayChapter(); updateChapterInfo(); saveState();
          speakParagraph();
        } else {
          stopReading();
        }
        return;
      }
      // highlight
      document.querySelectorAll('.content-display p').forEach(p => p.classList.remove('speaking'));
      const el = document.getElementById(`para-${currentParagraph}`);
      if (el) { el.classList.add('speaking'); el.scrollIntoView({ behavior: 'smooth', block: 'center' }); }

      const text = chapter.paragraphs[currentParagraph];
      try {
        currentUtterance = new SpeechSynthesisUtterance(text);
        currentUtterance.rate = parseFloat(els.speedSlider.value);
        if (selectedVoice) currentUtterance.voice = selectedVoice;

        currentUtterance.onend = () => {
          currentParagraph++;
          saveState();
          if (isPlaying && !isPaused) speakParagraph();
        };
        currentUtterance.onerror = (e) => {
          console.error('TTS error:', e);
          updateStatus('Error: ' + (e.error || 'speech synthesis'), 'stopped');
          // Try to move on
          currentParagraph++;
          if (isPlaying && !isPaused) speakParagraph();
        };
        speechSynth.speak(currentUtterance);
      } catch (e) {
        console.error(e);
        updateStatus('Error: Unable to speak text', 'stopped');
      }
    }

    function stopReading() {
      try { if (isSpeechSupported) speechSynth.cancel(); } catch {}
      isPlaying = false; isPaused = false;
      els.playPause.innerHTML = '‚ñ∂Ô∏è Play';
      document.querySelectorAll('.content-display p').forEach(p => p.classList.remove('speaking'));
      updateStatus('Stopped', 'stopped'); updateMediaPlaybackState('paused');
    }

    function nextParagraph() {
      if (!isSpeechSupported) return;
      try { speechSynth.cancel(); } catch {}
      currentParagraph++;
      if (currentParagraph >= (epubContent[currentChapter]?.paragraphs?.length || 0)) {
        if (currentChapter < epubContent.length - 1) {
          currentChapter++; currentParagraph = 0; displayChapter(); updateChapterInfo();
        } else {
          stopReading(); return;
        }
      }
      saveState();
      if (isPlaying && !isPaused) speakParagraph();
    }

    function previousParagraph() {
      if (!isSpeechSupported) return;
      try { speechSynth.cancel(); } catch {}
      currentParagraph = Math.max(0, currentParagraph - 1);
      saveState();
      if (isPlaying && !isPaused) speakParagraph();
    }

    function previousChapter() {
      if (currentChapter > 0) {
        currentChapter--; currentParagraph = 0;
        displayChapter(); updateChapterInfo(); saveState();
        if (isPlaying) { try { speechSynth.cancel(); } catch {} speakParagraph(); }
      }
    }
    function nextChapter() {
      if (currentChapter < epubContent.length - 1) {
        currentChapter++; currentParagraph = 0;
        displayChapter(); updateChapterInfo(); saveState();
        if (isPlaying) { try { speechSynth.cancel(); } catch {} speakParagraph(); }
      }
    }
    function jumpTo(ch, para=0) {
      if (ch < 0 || ch >= epubContent.length) return;
      currentChapter = ch; currentParagraph = Math.max(0, para|0);
      displayChapter(); updateChapterInfo(); saveState();
      if (isPlaying) { try { speechSynth.cancel(); } catch {} speakParagraph(); }
    }

    function updateSpeed() {
      const speed = parseFloat(els.speedSlider.value);
      els.speedValue.textContent = speed.toFixed(1) + 'x';
      if (currentUtterance) currentUtterance.rate = speed;
      saveState(true);
    }

    // --- Voice selection ---
    function loadVoices() {
      const list = speechSynth.getVoices() || [];
      if (!list.length) {
        // some browsers require delayed attempt
        setTimeout(() => {
          const retry = speechSynth.getVoices() || [];
          populateVoiceList(retry);
        }, 250);
      } else {
        populateVoiceList(list);
      }
    }
    function populateVoiceList(list) {
      // Show all available voices
      voices = list.slice();
      
      // Sort alphabetically
      voices.sort((a,b) => a.name.localeCompare(b.name));

      const prev = els.voiceSelect.value;
      els.voiceSelect.innerHTML = voices.map(v => `<option value="${escapeHtml(v.voiceURI)}">${escapeHtml(v.name)} ‚Äî ${escapeHtml(v.lang)}</option>`).join('');
      // try restore selection
      const saved = loadState();
      if (saved?.voiceURI && voices.find(v => v.voiceURI === saved.voiceURI)) {
        els.voiceSelect.value = saved.voiceURI;
        selectedVoice = voices.find(v => v.voiceURI === saved.voiceURI);
      } else {
        // default to first (hopefully female) voice
        selectedVoice = voices[0] || null;
        if (selectedVoice) els.voiceSelect.value = selectedVoice.voiceURI;
      }
    }
    function onVoiceChange() {
      const uri = els.voiceSelect.value;
      selectedVoice = voices.find(v => v.voiceURI === uri) || null;
      saveState(true);
      // restart current utterance with new voice if playing
      if (isPlaying && !isPaused) { try { speechSynth.cancel(); } catch {} speakParagraph(); }
    }

    // --- Bookmarks ---
    function addBookmark() {
      if (!storageKey) return;
      const nameRaw = els.bookmarkName.value.trim();
      const name = nameRaw || `Ch ${currentChapter+1}, ¬∂ ${currentParagraph+1}`;
      const bm = { name, chapter: currentChapter, paragraph: currentParagraph, t: Date.now() };
      bookmarks.push(bm);
      els.bookmarkName.value = '';
      renderBookmarks(); saveState(true);
      updateStatus(`‚≠ê Bookmark added: ${name}`, 'speaking');
    }
    function renderBookmarks() {
      els.bookmarkList.innerHTML = bookmarks.map((b, idx) => {
        const label = `${new Date(b.t).toLocaleString()} ‚Ä¢ ${b.name}`;
        return `<option value="${idx}">${escapeHtml(label)}</option>`;
      }).join('');
    }
    function goBookmark() {
      const idx = parseInt(els.bookmarkList.value, 10);
      if (isNaN(idx) || idx < 0 || idx >= bookmarks.length) return;
      const b = bookmarks[idx];
      jumpTo(b.chapter, b.paragraph);
    }
    function deleteBookmark() {
      const idx = parseInt(els.bookmarkList.value, 10);
      if (isNaN(idx) || idx < 0 || idx >= bookmarks.length) return;
      const [removed] = bookmarks.splice(idx, 1);
      renderBookmarks(); saveState(true);
      updateStatus(`üóëÔ∏è Deleted bookmark: ${removed.name}`, 'stopped');
    }

    // --- Persistence ---
    function saveState(skipDebounce=false) {
      if (!storageKey) return;
      const state = {
        chapter: currentChapter, paragraph: currentParagraph,
        speed: parseFloat(els.speedSlider.value),
        voiceURI: selectedVoice?.voiceURI || null,
        bookmarks
      };
      try { localStorage.setItem(storageKey, JSON.stringify(state)); } catch {}
    }
    function loadState() {
      if (!storageKey) return null;
      try {
        const raw = localStorage.getItem(storageKey);
        return raw ? JSON.parse(raw) : null;
      } catch { return null; }
    }

    // --- Media Session (background controls) ---
    function initMediaSession(title) {
      try {
        if ('mediaSession' in navigator) {
          navigator.mediaSession.metadata = new MediaMetadata({
            title: title || 'ePub Reader',
            artist: 'Text-to-Speech',
            album: 'ePub Reader'
          });
          navigator.mediaSession.setActionHandler('play', () => { if (!isPlaying) startReading(); else if (isPaused) togglePlayPause(); });
          navigator.mediaSession.setActionHandler('pause', () => { if (isPlaying && !isPaused) togglePlayPause(); });
          navigator.mediaSession.setActionHandler('previoustrack', () => previousParagraph());
          navigator.mediaSession.setActionHandler('nexttrack', () => nextParagraph());
          navigator.mediaSession.setActionHandler('seekforward', () => nextParagraph());
          navigator.mediaSession.setActionHandler('seekbackward', () => previousParagraph());
          updateMediaPlaybackState('paused');
        }
      } catch {}
    }
    function updateMediaPlaybackState(state) {
      try {
        if ('mediaSession' in navigator) navigator.mediaSession.playbackState = state; // 'none' | 'paused' | 'playing'
      } catch {}
    }

    // --- Wake Lock (optional to reduce device sleeping) ---
    async function toggleWakeLock() {
      if (!('wakeLock' in navigator)) {
        updateStatus('Wake Lock API not supported on this device.', 'paused');
        els.keepAwake.checked = false; return;
      }
      if (els.keepAwake.checked) {
        try {
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock.addEventListener('release', () => { els.keepAwake.checked = false; });
          updateStatus('Screen will stay awake while enabled.', 'speaking');
        } catch (e) {
          updateStatus('Unable to acquire wake lock.', 'stopped');
          els.keepAwake.checked = false;
        }
      } else {
        releaseWakeLock();
      }
    }
    function releaseWakeLock() {
      try { if (wakeLock) wakeLock.release(); } catch {}
      wakeLock = null;
    }

    // --- Helpers ---
    function updateStatus(text, className) {
      els.status.textContent = text;
      els.status.className = 'status active ' + className;
      if (className === 'stopped') {
        setTimeout(() => els.status.classList.remove('active'), 2200);
      }
    }
    function escapeHtml(str) {
      return (str || '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }
  </script>
</body>
</html>
